## 네트워크 요청 최적화 방법에 대해 설명해주세요.

우선 데이터를 캐싱하는 방법이 있습니다. 브라우저의 http 캐시 헤더를 적절히 설정해서 캐싱을 할 수 있고, Service Worker를 사용하면 오프라인 상태에서도 애플리케이션이 동작할 수 있습니다.
데이터 전송을 최적화하는 방법도 여러 가지 있는데요, HTTP/2를 활용하여 하나의 연결로 여러 개의 요청을 동시에 처리하거나, 이미지를 최적화해서 불필요한 데이터 전송을 줄입니다. 또한 CDN을 사용하여 사용자와 가까운 위치에서 리소스를 제공할 수 있습니다.
요청 제어 기법을 사용할 수도 있습니다. 디바운스나 쓰로틀을 적용할 수도 있고, 여러 개의 작은 요청을 하나로 병합하거나 요청의 우선순위를 조정하여 중요한 데이터를 먼저 로드하게 할 수 있습니다.

## 타입스크립트를 사용하는 이유를 설명해주세요.

런타임 전에 타입 에러를 발견할 수 있어서 런타임 에러를 줄이고 코드 안정성을 향상시킬 수 있다는 점이 가장 큰 장점이라고 생각합니다.
그리고 타입 정의를 IDE가 아니까 IDE가 더 많은 정보를 제공할 수 있다는 점도 편리합니다. 제가 예전에 자바스크립트로 프로젝트를 했을 때는 API 응답 형식 등을 따로 문서화해두고 매번 찾아보거나, 아예 파일 밑에 주석으로 적어두기도 했습니다. 타입스크립트에서는 제가 따로 찾아보고 비교해보지 않아도 IDE가 알려준다는 점이 편리했습니다.
또한 클래스, 인터페이스, 접근제어자(private 같은거) 등을 지원하기 때문에 객체지향 프로그래밍도 가능합니다.

## 리액트에서 컴포넌트란 무엇인가요?

https://www.maeil-mail.kr/question/94

리액트에서 컴포넌트란 UI를 구성하는 독립적이고 재사용 가능한 코드의 단위입니다. 특정 UI나 기능을 캡슐화해서 사용합니다. 그래서 여러 페이지에서 재사용할 수 있고 유지보수를 쉽게 할 수 있습니다.

#### 컴포넌트 설계 시 고려 사항

단일 책임 원칙을 지키는 편이 좋습니다. 컴포넌트의 역할을 명확히 하고, 비즈니스 로직과 UI 로직을 분리하는 등 하나의 컴포넌트가 너무 많은 책임을 지지 않게 하는 편이 유지보수에 좋습니다.
그리고 여러 군데에서 재사용되는 공통 컴포넌트의 경우 유연하게 설계하고 props로 필요한 내용을 주입받아 다양하게 재사용되도록 하는 편이 좋습니다.

## Tanstack Query를 사용하는 이유를 설명해 주세요.

https://www.maeil-mail.kr/question/86

서버 상태 관리를 편리하게 하기 위해 사용합니다. 서버에서 가져오는 데이터들을 비동기적으로 fetch, 갱신, 무효화, 에러 및 로딩 상태 처리, 캐싱 등의 기능을 직접 구현할 필요 없이 간편하게 사용할 수 있습니다. 다만 캐싱 기능이 강력한만큼 옵션 설정 등이 복잡할 수 있고, 쿼리 키 설계나 데이터 무효화 등 이해해야 하는 개념이 많아서 초기 러닝 커브가 있습니다. 또한 상태 간 의존 관계가 복잡한 경우 Tanstack query만으로 해결하기 어려워 zustand, jotai 같은 전역 상태 관리 라이브러리를 추가로 필요로 할 수도 있습니다.

## CORS(Cross-Origin Resource Sharing)에 대해 설명해주세요.

브라우저에는 기본적으로 동일 출처 정책(Same-Origin Policy)이 있는데, 동일 출처가 아니면 DOM 접근, 쿠키나 웹스토리지 접근, ajax 요청을 제한합니다. 서버가 다른 출처의 요청을 허용할 수 있게 해주는 게 CORS(Cross-Origin Resource Sharing)입니다.
CORS 이슈는 클라이언트 이슈에 해당하지만(동일 출처 정책 때문에 발생하므로) 해결은 서버에서 해 줘야 합니다. Access-Control-Allow-Origin 헤더를 설정하여 특정 출처를 허용해 주면 됩니다. 인증 관련 요청이면 추가로 서버에서 Access-Control-Allow-Credentials: true 설정을 하고 클라이언트에서도 credential 옵션을 true로 설정해 줘야 합니다. 개발 환경에서는 프록시 서버로 우회할 수도 있습니다.

## 웹 보안과 관련된 주요 취약점과 대응 방안에 대해 설명해주세요.

우선 XSS는 입력 폼에 악성 스크립트를 넣어서 다른 사용자가 해당 페이지를 이용할 때 실행되도록 하는 공격입니다. 이를 막으려면 입력값을 검증하고 코드로 인식되지 않게 특수기호를 이스케이프 처리하거나, 콘텐츠 보안 정책(CSP)으로 웹페이지에서 실행할 수 있는 스크립트의 출처를 제한하는 방법이 있습니다. 쿠키에는 httpOnly 설정을 넣어서 자바스크립트에서 쿠키에 접근 못 하게 하고, 웹 스토리지는 이런 식으로 막기 어려우니 민감한 정보를 저장하면 안 됩니다.
SQL injection은 입력 폼에 쿼리를 넣어서 DB에 접근하거나 정보를 빼오는 방식입니다. 이를 방지하기 위해 쿼리문과 데이터 부분을 분리해서 사용자 입력을 매개변수로 처리하는 Prepared Statement를 쓰는 것이 좋습니다. 저는 타임코디 프로젝트에서 SQLAlchemy를 써서 ORM을 경험해 본 적이 있습니다.
CSRF(Cross-Site Request Forgery)는 사용자가 인증된 상태에서 요청을 위조하는 공격 방식입니다. 예를 들어 사용자가 은행 앱에 로그인한 상태에서 악성 웹사이트에 들어가게 해서 사용자의 세션을 이용해 계좌이체 요청을 보낸다든지 하는 방식입니다. 이걸 막는 대표적인 방법은 CSRF 토큰인데요, 주로 http form의 hidden 필드에 토큰을 넣어서 서버가 세션에 저장된 토큰과 요청 들어온 토큰이 일치하는지 확인할 수 있습니다.

## JWT(JSON Web Token)에 대해 설명해주세요.

json web token은 주로 인증이나 정보 교환에 사용되는 표준화된 문자열입니다. 그게 헤더, 페이로드, 시그니처 세 부분으로 구성되어 있고 점으로 구분됩니다. 헤더에는 토큰 타입과 어떤 해싱 알고리즘을 사용했는지 적혀 있습니다. 페이로드에는 토큰에 담을 실제 데이터가 들어갑니다. user id와 권한(admin) 같은 게 들어가는데, 암호화되지 않고 인코딩만 되므로 민감한 정보는 여기 넣으면 안 됩니다. 마지막으로 시그니처는 헤더와 페이로드를 비밀 키를 사용해서 서명한 부분입니다. 서버는 클라이언트가 보낸 헤더와 페이로드를 기반으로 새 시그니처를 계산해서, 두 값이 일치하면 데이터가 위변조되지 않았다고 판단합니다. 비밀 키는 서버에만 있기 때문에, 클라이언트에서 헤더나 페이로드를 조작하더라도 시그니처 검증에서 실패합니다.
jwt의 장점은 첫째, stateless하다는 점입니다. 서버에 세션 상태를 저장하지 않기 때문에 서버의 확장성이 좋습니다(여러 개의 서버로 분산되어 있어도 인증 로직이 간단). 또한 요청마다 세션 상태를 조회할 필요 없이 토큰만 검증하면 돼서 서버 부하가 적습니다. 그래서 네트워크가 제한된 모바일 등의 환경에서도 사용하기 좋고, 여러 기기에서 동시에 요청해도 기기별로 세션을 따로 관리할 필요가 없습니다.
또한 간단한 json 형식이기 때문에 다양한 언어나 플랫폼에서 호환되며 http 헤더나 url 쿼리 파라미터로 쉽게 전달할 수 있습니다.
하지만 주의해야 할 점은 토큰은 암호화되는 게 아니라 단순 인코딩이라 디코딩이 쉽기 때문에 민감한 정보를 페이로드에 담으면 안 됩니다. 또한 https를 사용해 네트워크 전송 과정에서 토큰이 탈취되지 않도록 해야 합니다.

## 자바스크립트 Promise에 대해서 아는 대로 설명해주세요.

https://www.maeil-mail.kr/question/65

비동기 작업할 때 쓰는 객체입니다. 기본적으로 세 가지 상태를 가지는데 pending, fulfilled, rejected 입니다. 비동기 작업이 성공하면 resolve를 호출해서 결과를 반환하고 상태를 fulfilled로 변경합니다. 실패하면 reject를 호출해서 에러를 반환하고 rejected 상태로 변경합니다.
작업이 다 끝나서 성공하면 then, 에러가 발생하면 catch를 사용해서 비동기 작업 이후의 결과를 처리할 수 있습니다.

## useEffect가 호출되는 시점에 대해 설명해 주세요.

https://www.maeil-mail.kr/question/64

우선 맨 처음 컴포넌트가 마운트될 때, 즉 처음 렌더링되고 나서 호출되고, (API 호출, 데이터 초기화 등)
그 다음에 의존성 배열에 지정된 값이 업데이트될 때마다 호출되고, (count 값이 변경될 때마다 실행하는 등)
마지막으로 컴포넌트가 언마운트될 때 useEffect의 return값으로 지정된 클린업 함수가 호출됩니다. (이벤트 리스너 제거, 타이머 해제 등)

## 시맨틱 마크업이란 무엇이며, 왜 중요한가요?

https://www.maeil-mail.kr/question/59

시맨틱 마크업은 html에서 div 같은 거 말고 header, footer, button 이런 요소의 의미가 잘 드러나는 시맨틱 태그를 사용하는 것을 말합니다. 시맨틱 마크업이 필요한 이유는 첫째, SEO에 유리합니다. 검색 엔진이 시맨틱 구조를 통해 페이지를 제대로 이해할수록 검색 결과에서 페이지가 상위에 노출될 수 있습니다. 둘째, 웹 접근성이 향상됩니다. 시각장애인을 위한 스크린 리더 등이 시맨틱 태그를 기반으로 웹페이지를 더 잘 해석할 수 있습니다.

### CSR에서도 시맨틱 마크업이 영향 있을까?

검색엔진이 페이지 크롤링할 때 CSR 렌더링 전의 초기 컨텐츠만 인식할 수 있어서 SSR에 비해서는 다소 제한적이지만, 최근에는 구글 등에서 자바스크립트 렌더링을 지원하기 시작했기 때문에 페이지의 시맨틱 구조를 어느 정도는 파악할 수 있습니다.

## 타입스크립트의 타입과 인터페이스의 차이점을 설명해주세요.

https://www.maeil-mail.kr/question/58

저는 주로 객체일 때 인터페이스를 사용하고 나머지 경우에 타입을 사용합니다.
인터페이스는 extends로 상속할 수 있고, 같은 이름의 인터페이스를 여러 번 선언하면 다 하나로 병합되는데 저는 개인적으로 이건 별로 선호하지 않습니다. 헷갈려서요. 개인적으로는 상속 관계를 표현하기에 좋다고 생각해서 사용합니다.
타입은 typeof 키워드로 타입을 알 수 있고, 유니언과 인터섹션을 지원하기 때문에 여러 타입 중 하나라든가 하는 식으로 타입을 지정해야 할 때 사용합니다.

## 자바스크립트는 싱글 스레드 언어인데, 어떻게 동시에 여러 작업들을 수행하나요?

https://www.maeil-mail.kr/question/57

자바스크립트는 싱글 스레드지만, 브라우저나 node.js 환경에서 비동기 처리를 지원합니다.
브라우저에서는 setTimeout 같은 비동기 작업을 Web API에 넘기고 다른 코드 실행을 이어갑니다. Web API에서 비동기 작업이 완료되면 콜백함수는 태스크 큐에서 대기하다가 이벤트 루프에서 콜 스택이 비면 태스크 큐의 작업을 콜 스택으로 옮겨와 실행합니다. Node.js에서는 브라우저의 Web API 역할을 런타임 이벤트 루프와 libuv 라이브러리가 대체합니다.
태스크 큐에는 매크로태스크 큐와 마이크로태스크 큐가 있습니다. 일반적인 비동기 작업은 매크로태스크 큐에서 진행되고, 마이크로태스크 큐에는 Promise.then이나 MutationObserver 같은 우선순위가 더 높은 비동기 작업들이 대기합니다. 이벤트 루프는 먼저 마이크로태스크 큐를 먼저 확인한 뒤에 매크로태스크 큐로 넘어갑니다.

## 이미지 크기가 클 경우 렌더링 속도가 느려질 텐데, 이를 개선하기 위한 방법들을 설명해주세요.

https://www.maeil-mail.kr/question/54

네 가지 정도의 방법이 있습니다.
첫 번째는 jpg나 png 같은 이미지 포맷을 WebP나 AVIF 같은 포맷으로 변환하는 방법입니다. 이미지 품질을 유지하면서도 파일 크기를 줄일 수 있지만, 일부 구버전 브라우저에서 지원하지 않는 경우도 있어서 호환성을 고려해야 합니다. `<picture>` 요소 내부에 WebP나 AVIF와 같은 고효율 포맷을 우선 설정하고, 브라우저가 이를 지원하지 않을 경우 JPEG나 PNG와 같은 기본 포맷을 로드하도록 할 수 있습니다.
두 번째는 이미지의 크기가 작을수록 속도가 빨라지니 필요한 크기보다 너무 큰 사이즈를 그 때 가서 조절하지 말고 미리 작은 사이즈를 준비하거나, 반응형 이미지로 srcset와 sizes 속성을 사용해서 화면 크기에 맞는 이미지를 선택적으로 렌더링할 수 있습니다.
세 번째는 CDN(Content Delivery Network)을 사용하여 지리적으로 가까운 캐시 서버에서 이미지를 다운로드하는 방법입니다.
마지막으로 Lazy Loading을 통해 당장 화면에 보이지 않는 이미지는 늦게 로딩하도록 할 수 있습니다.

## 프론트엔드 E2E 테스트에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/52

엔드투엔드 테스트는 사용자 입장에서 처음부터 끝까지 사용자 경험을 시뮬레이션해보는 테스트입니다. 실제 사용과 가장 가까운 테스트인만큼 정말 중요하지만, 작성과 실행 비용이 높으므로 happy path에 집중하는 것이 좋습니다. 그리고 구체적으로 어디서 오류가 생겼는지 세부적으로 찾기 어려우므로 유닛 테스트, 통합 테스트와 병행하는 것이 좋습니다.
사람이 직접 할 수도 있지만, cypress나 Selenium같은 자동화된 도구로 테스트할 수도 있습니다. 부트캠프에서 cypress를 다뤄 본 적이 있는데, 초기 세팅이 좀 어려웠지만 코드가 직관적이고 브라우저에서 실행되는 모습이 실제로 보여서 좋았습니다.

## CSS Flexbox와 Grid의 차이점에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/51

둘 다 레이아웃을 짤 때 쓰는 건데, flex는 1차원 레이아웃이고 grid는 2차원 레이아웃입니다. flex는 row나 column 중 한 방향으로 정렬하는 거고, grid는 row와 column을 모두 사용합니다.
그래서 grid는 복잡한 레이아웃을 구성하거나, 웹페이지 전체 구조를 잡을 때 쓰면 좋습니다. 카드 레이아웃이나 갤러리 형식처럼요. grid-template-row나 col 같은 속성으로 row와 column의 크기를 미리 정해놓고 그 셀 안에 요소를 배치하는 방식입니다.
반면 flex는 주로 요소가 컨테이너 크기나 위치에 맞춰서 자동으로 정렬되기 때문에 유연하게 요소가 추가되거나 삭제될 때 사용하기 좋습니다. 가로나 세로 한 방향으로 요소들을 한 줄로 정렬하고 간격을 조절하기에 좋습니다.

## SSR(Server Side Rendering)에 대해 설명해주세요.

https://www.maeil-mail.kr/question/48

서버사이드렌더링은 초기 화면을 클라이언트가 아니라 서버가 렌더링해서 렌더 트리까지 완성된 html을 클라이언트한테 주고 클라이언트는 파싱만 하는 개념입니다. 이후에 hydration 과정에서 이벤트 리스너 붙이고 하는 자바스크립트 동작을 실행해서 정적인 화면을 동적으로 전환합니다. 원래 기본적인 클라이언트사이드렌더링에서는 서버에서 비어 있는 뼈대 html만 제공하고 브라우저에서 필요한 자바스크립트 번들을 다운받고 실행해서 DOM 트리부터 그리면서 동적으로 화면을 그립니다.
SSR은 초기 로딩 속도가 빠르고 SEO에 유리합니다. 검색 엔진이 크롤링할 때 컨텐츠 인식하기가 쉽기 때문입니다. 그래서 SEO가 중요한 커머스나 블로그 같은 서비스에 특히 적합합니다. 단점은 CSR보다 UI 그리는 건 빠른데 상호작용 되기까지는 비슷한 시간이 걸리니까 사용자 입장에서 버튼은 보이는데 클릭이 안 되는 경험을 할 수도 있습니다. 그리고 서버의 부하가 크고, 양쪽 모두의 렌더링을 고려하므로 개발 과정이 좀 더 복잡합니다.

## 웹 접근성의 개념과 개선 방법에 대해 설명해주세요.

https://www.maeil-mail.kr/question/47

웹 접근성은 장애인이나 노약자 등 취약한 사람들도 웹페이지를 잘 이용할 수 있는지에 대한 것입니다. 예를 들어 시각 장애인이 스크린 리더로 웹 페이지를 '듣기' 위해서는 다 div로 도배된 것보다는 button, li, h1 등 html 태그에 의미가 적확하게 담겨 있고 html 구조가 단순할수록 좋습니다. 충분하지 않을 때는 ARIA 속성을 넣어서 동적 컨텐츠나 복잡한 UI를 제대로 인식할 수 있게 도울 수도 있습니다. 혹은 focus-visible 같은 걸로 키보드 내비게이션을 지원할 수도 있습니다.
이런 웹 접근성 개선은 장애인 사용자에게만 좋은 게 아니라 모두에게 이점이 있습니다. 이렇게 코드를 짰을 때 SEO가 좋아져서 검색에 노출이 더 잘 된다거나 크롤링이 용이해진다거나, 하다못해 개발자 입장에서도 가독성이 좋아집니다.
저는 웹 접근성 관련된 부분은 약간 컨벤션처럼 가져가는 게 좋다고 생각합니다. 나중에 덧붙이려고 하면 고민이 많이 되고 어려운데, 처음 코드를 칠 때부터 좀 생각 없이 하게 만들면 좀 품이 덜 들면서도 최소한의 퀄리티가 나오는 것 같습니다. 그래서 처음부터 나쁜 습관을 들이지 않으려고 하는 편입니다. 그렇게 컨벤션으로 커버하지 못한 케이스는, 일일이 고려하기엔 너무 다양한 장애의 종류가 있기 때문에 실제 고객에게서 피드백이 왔을 때 맞춤형으로 반영을 하게 될 것 같습니다.

## useEffect와 useLayoutEffect의 차이점에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/46

useEffect는 화면이 실제로 사용자에게 그려진 후에 실행됩니다. 그래서 useEffect는 보통 데이터를 가져오는 작업이나 이벤트 리스너 추가 등 화면에 직접적인 영향을 주지 않는 작업에 주로 사용됩니다.
반면 useLayoutEffect는 화면에 내용이 그려지기 전에 모든 작업이 완료됩니다. 그래서 DOM의 크기를 측정해서 다른 요소의 위치를 조정해야 할 때 useLayoutEffect를 사용하면 즉각적으로 변경사항이 반영되어 화면 깜빡임이나 불필요한 재렌더링을 방지할 수 있습니다. 주의할 점은 useLayoutEffect는 동기적으로 실행되기 때문에 렌더링을 느려지게 할 수 있습니다.

## async/await에 대해 설명해보세요.

async랑 await은 자바스크립트에서 Promise를 좀 더 쉽게 쓸 수 있도록 해주는 키워드인데요.
함수 앞에 async 선언을 하면 그 함수는 Promise 객체를 반환합니다. Promise 객체에는 진행 상태를 나타내는 pending, fulfilled, rejected 상태도 저장되어 있고, 성공하면 결과값 데이터, 실패하면 에러 정보도 저장됩니다. 그리고 `.then()`, `.catch()`, `.finally()` 같은 메서드가 포함되어 있어서 Promise의 상태 변화에 따라 적절한 동작을 연결할 수 있습니다.
async 선언을 한 함수 안에서는 await을 쓸 수 있게 됩니다. 예를 들어 서버에 get 요청 보내서 데이터 받아오는 함수 앞에 await을 선언합니다. 그럼 그거 하는 동안에 async 함수 안에 있는 다른 코드들은 실행되지 않고 대기합니다. 하지만 async 밖에 있는 코드들은 기다리지 않고 실행됩니다.
이렇게 시간이 오래 걸리는 작업이 완료될 때까지 기다리지 않고 다음 작업을 처리할 수 있는 방식을 비동기 프로그래밍이라고 합니다.

## 리액트에서 index를 key값으로 사용하면 안되는 이유에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/42

배열의 인덱스 말씀하시는 거죠? 그러면 배열 순서가 바뀌거나 했을 때 문제가 생길 수 있습니다. 배열 중간에 새로운 값이 추가되거나 삭제될 수도 있고요. 그러면 2번 폼에 입력한 값이 3번 폼으로 잘못 연결된다든지 하는 버그가 발생할 수도 있고, 그러지 않더라도 변경된 부분부터 그 이후 인덱스는 싹 다 바뀌기 때문에 렌더링을 다 새로 해야 합니다.

#### key로 사용되는 고유한 값의 생성 방법에는 어떤 것들이 있나요?

데이터베이스에서 오는 고유 id값을 사용하는 것이 제일 안전하다고 생각합니다. 그런 게 여의치 않으면 UUID 같은 전역적으로 고유한 id를 생성해주는 라이브러리를 쓸 수도 있겠습니다.

## 디바운스와 쓰로틀에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/41

디바운스와 쓰로틀은 이벤트 핸들러가 너무 자주 실행되는 것을 막는 방법입니다.
디바운스는 마지막 이벤트가 발생한 후 일정 시간이 지나야 이벤트 핸들러가 실행되는 방식입니다. 예를 들어 사용자가 폼에 글자를 입력할 때마다 검색 요청을 보내면 부하가 지나치게 커지기 때문에, 사용자가 입력을 멈춘 후 일정 시간이 지나면 검색 요청을 보내는 방식입니다.
쓰로틀은 일정 시간 간격 동안 발생한 이벤트 중 첫 번째나 마지막 이벤트만 처리하는 방식입니다. 예를 들어 사용자가 버튼을 연타할 경우 클릭할 때마다 이벤트가 발생하면 부하가 지나치게 커지기 때문에, 쓰로틀을 적용해 일정 시간 동안 여러 번 연타해도 한 번만 처리하게 할 수 있습니다.

#### 디바운스와 쓰로틀 중에서 무한 스크롤 구현 시 어떤 방식을 선택하시겠습니까? 그 이유는 무엇인가요?

무한 스크롤을 하려면 사용자가 페이지 맨 밑에 스크롤을 내렸을 때 서버에 요청이 가야 하는데,
디바운스는 스크롤을 내린 후 일정 시간이 지나야 요청이 가기 때문에 부적합합니다.
쓰로틀을 사용해서 스크롤이 맨 밑으로 내려가자마자 추가 데이터 요청을 넣도록 하겠습니다.

## 브라우저의 성능 최적화를 할 수 있는 방법에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/40

우선 코드 스플리팅을 통해 자바스크립트 파일을 전부 한꺼번에 불러오는 대신 당장 필요한 부분만 먼저 로드하여 페이지 로딩 속도를 개선할 수 있습니다.
그리고 이미지나 비디오 같은 무거운 리소스에 대해서 레이지 로딩을 적용할 수도 있습니다. 사용자가 페이지를 스크롤해서 밑에 있는 이미지가 필요해지면 그때 가서 이미지를 로드하는 식으로 구현합니다. 이미지에 대해서는 이미지 최적화로 파일 크기를 줄이거나 가벼운 포맷으로 변환할 수도 있습니다.
이외에도 브라우저가 캐싱을 할 수도 있고, 불필요한 DOM 크기를 줄이거나 script 태그에 async나 defer 속성을 사용해서 비동기 로딩을 하는 방법도 있습니다.

## 이벤트 전파(event propagation)에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/39

버튼 클릭 같은 이벤트가 발생했을 때, 이벤트 전파 순서는 캡처링, 타깃, 버블링 순서입니다.
DOM 트리의 최상위 요소(document 또는 window)부터 시작하여, 이벤트가 발생한 타깃 요소(여기서는 버튼)까지 내려가며 이벤트를 탐색하는 과정을 캡처링이라고 합니다.
두 번째 타깃 단계에서는 이벤트 리스너가 타깃 요소에서 실행됩니다
세 번째 버블링 단계에서는 다시 점점 상위 요소로 이벤트가 전파됩니다.
기본적으로 이벤트 리스너는 버블링 단계에서 실행되지만, 캡처링 단계에서 실행되도록 설정할 수도 있습니다.

#### 추가질문 1: 버블링은 왜 필요한가?

이벤트 위임(Event Delegation): 상위 요소에서 한 번에 이벤트를 처리 (예를 들어 리스트의 각 메뉴를 클릭했을 때)
팝업 외부를 클릭하면 팝업이 닫히는 등의 이벤트를 처리하기에 유용합니다.

#### 추가질문 2: 이벤트 전파 멈추는 방법

`event.stopPropagation()`을 호출하면, 이벤트는 버블링 단계로 더 이상 전파되지 않습니다.
예시: 모달 바깥을 클릭하면 모달이 닫히게 했을 때, stopPropagation 안 하면 모달 내부를 클릭해도 닫힘.

## CommonJS와 ES Module의 차이점에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/38

commonJS와 ES Module은 자바스크립트에서 모듈을 불러오고 내보내는 두 가지 방식입니다.
CommonJS는 자바스크립트 초창기부터 쓰던 방식인데, 동기적으로 로드하고 트리 쉐이킹이 지원되지 않습니다. require로 모듈을 동적으로 불러올 수 있기 때문입니다.
ES Module은 ES6때 나온 새로운 모듈 시스템입니다. Promise를 기반으로 비동기적으로 작동되며, 정적 분석이 가능해 트리 쉐이킹을 할 수 있습니다.
ES Module 방식을 쓰려면 package.json에서 `"type": "module"` 을 명시해야 합니다. 최근에는 대부분 ES Module 방식을 쓰지만, 레거시 문제로 CommonJS도 여전히 사용됩니다.

#### 추가질문: 트리 쉐이킹이란?

자바스크립트 번들러(Webpack, Rollup 등)가 사용하지 않는 코드를 자동으로 제거해서 최종 번들 크기를 줄이는 최적화 기법.
트리 쉐이킹이 작동하려면 코드가 정적 구조로 작성되어 어떤 모듈이 어디서 사용될지 컴파일 시점에 알 수 있어야 한다. CommonJS는 require로 모듈을 동적으로 불러올 수 있어서 정적 분석이 어렵다.

## 자바스크립트 함수에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/33

자바스크립트의 함수는 일급 객체입니다. 값처럼 자유롭게 변수에 할당하거나, 함수에 인자 또는 리턴값으로 쓰이거나, 런타임 중에 함수가 새로 생성되는 것이 가능합니다. 그래서 고차 함수 같은 식으로도 사용될 수 있습니다. (고차 함수가 뭐죠: 다른 함수를 인자로 받거나 리턴값으로 뱉는 함수입니다. Array의 map이나 forEach 같은 함수들이 있습니다.)
그리고 자바스크립트 함수는 lexical scope를 따릅니다. 함수의 호출 위치와는 관계없이 함수가 **정의**된 위치에 따라 변수에 접근할 수 있는 scope가 결정됩니다. 그래서 클로저가 가능합니다. 클로저는 내부 함수가 외부 함수의 변수 스코프를 기억해서 함수 실행이 종료된 후에도 또 호출할 때 계속 참조할 수 있는 기능을 말합니다.
화살표 함수의 경우에는 this를 렉시컬 스코프에 바인딩하기 때문에, 콜백 함수에서 기존 함수보다 더 직관적으로 사용할 수 있습니다. 다만, 생성자 함수로는 사용할 수 없고, arguments 객체를 지원하지 않는 등의 제약이 있습니다.

## 쿠키, 세션, 웹스토리지의 차이를 설명해보세요.

쿠키는 브라우저에 저장되고, http 요청마다 서버로 전송됩니다.
세션은 서버에 저장되고, 브라우저는 세션 id를 쿠키로 저장하거나 url에 포함시켜서 서버에 전달합니다. 브라우저를 닫으면 기본적으로는 세션이 종료되지만 유효기간을 설정해서 지속되게 할 수 있습니다. 데이터가 서버에 있으므로 보안에 더 적합하지만, 대규모 사용자가 접속하면 서버 메모리를 많이 차지할 수 있습니다.
웹 스토리지는 브라우저만 저장하고 서버로 전송되지 않습니다. 로컬 스토리지는 삭제하지 않는 한 영구적으로 저장되고, 세션 스토리지는 브라우저 탭을 닫으면 삭제됩니다.

#### 추가질문: 각각 어떤 상황에서 사용하면 적절한가요?

쿠키는 클라이언트와 서버 간 상태를 유지하기 위해 사용됩니다. 예를 들어, 세션 ID나 사용자 인증 토큰을 쿠키에 저장하면 서버와의 상태를 동기화할 수 있습니다.사용자의 행동을 추적하거나 간단한 사용자 설정 등을 저장할 때도 쓰입니다.
세션은 클라이언트에 저장하면 안 되는 보안이 중요한 데이터를 저장할 때 쓰입니다. 클라이언트는 세션 ID만 저장하며, 실제 데이터는 서버에서 관리하기 때문에 민감한 정보를 안전하게 보호할 수 있습니다.
웹 스토리지는 서버 요청 없이 데이터를 활용할 때 쓰입니다. 예를 들어 비회원 장바구니 기능을 로컬스토리지에 저장해두고 주문하기를 누르면 회원가입 창으로 이동시킬 수 있습니다. 폼 입력과 같이 현재 탭을 닫으면 삭제되게 하고 싶을 때는 세션 스토리지를 씁니다.

## 자바스크립트 호이스팅에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/31

변수와 함수 선언을 제일 먼저 끌어올려서 하는 것을 호이스팅이라고 합니다. 자바스크립트에서는 변수와 함수 선언을 코드 어디에서 하더라도 최상단에서 선언한 것처럼 호이스팅이 됩니다. 그래서 함수 호출 코드가 더 위에 있고 밑에서 함수를 선언한다고 해도 문제가 없습니다. 하지만 호이스팅되는 것은 선언뿐이지 값 할당은 호이스팅되지 않습니다.
그래서 초기화 전까지 var로 선언된 변수는 undefined로 취급되는데, let과 const는 선언되었어도 초기화 전까지는 접근할 수 없습니다 - ReferenceError가 발생합니다.

### 추가질문: var, let, const의 차이를 설명해주세요.

let과 const는 var의 한계를 보완하기 위해 ES6에서부터 도입된 문법입니다.
var는 함수 스코프를 가집니다. 함수 내부에서 선언되면 그 함수 안에서만 동작하는데, 함수 외부에서 선언된 var는 전역 변수처럼 동작합니다. if문 같은 블록 안에서 선언되더라도 블록 밖에서 역시 접근 가능합니다. 반면 let과 const는 블록 스코프를 가지므로 블록 안에서 선언하면 블록 밖에서 접근할 수 없습니다.
또한 var는 같은 스코프 내에서 재선언이 가능한데 let과 const는 재선언이 불가능합니다. 값을 재할당하는 것은 var와 let에서 가능하고 const는 상수 취급되기 때문에 재할당이 불가능합니다. 다만 객체나 배열의 내부 값을 변경하는 것은 가능합니다. 주소값이 변하지 않기 때문에.
마지막으로 호이스팅 시에 var는 초기화 전에 undefined로 취급되지만 let과 const는 초기화 전에 접근하면 레퍼런스 에러가 뜹니다.
최근에는 var는 잘 쓰이지 않고, const를 주로 사용하면서 재할당이 필요한 경우에만 let을 사용하는 것을 권장합니다.

## 리액트의 render phase와 commit phase에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/30

리액트의 렌더링 과정은 크게 렌더 페이즈와 커밋 페이즈로 나눌 수 있습니다. 렌더 페이즈는 props나 state의 변화에 따라서 어떻게 UI를 변경할지를 가상 DOM에서 먼저 계산해보는 단계입니다. 이 단계는 브라우저와 독립적으로 작동하며, 작업 우선순위에 따라 비동기적으로 실행될 수 있습니다. 이렇게 계산된 내용을 커밋 페이즈에서 실제 DOM에 반영합니다.

## 인터넷 창에서 www.google.com 를 입력하면 무슨 일이 일어나는지 설명해주세요.

https://www.maeil-mail.kr/question/20

우선 DNS 조회부터 시작합니다. www google.com 이라는 도메인 이름을 브라우저가 IP 주소로 변환하기 위해서 DNS를 조회하는데요, 캐시된 DNS 기록이 있는지 먼저 확인하고 없으면 로컬 DNS 서버에 요청해서 해당 IP 주소를 얻습니다.
그 다음에 브라우저와 서버 간에 3-way 핸드셰이크로 TCP 연결을 합니다. TCP는 데이터를 신뢰성 있게 전달하기 위한 연결 프로토콜인데요, 브라우저가 먼저 SYN 패킷을 전송하고, 서버가 그걸 받아서 응답으로 SYN-ACK 패킷을 전송하고, 다시 브라우저가 응답을 받고 ACK 패킷을 보냄으로써 연결이 완료됩니다.
그러면 이제 브라우저가 GET 요청 같은 HTTP 요청을 보낼 수 있습니다. HTTPS를 사용한다면 이 단계에서 SSL-TLS 핸드셰이크를 수행함으로써 보안 인증서를 교환하고 암호화 키를 협상해서 서버의 신원을 확인하고 이후 통신이 암호화 상태로 진행될 수 있게 합니다.
서버로부터 요청에 대한 응답이 오면, 브라우저는 받은 리소스들을 바탕으로 브라우저 렌더링 파이프라인을 진행합니다.

## 브라우저 렌더링 파이프라인에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/19

우선 브라우저가 서버에서 html 코드부터 바이트로 가져옵니다. 그리고 파서가 이걸 문자로 변환하고, 문자를 다시 html 토큰으로 파싱해서 DOM 트리를 만듭니다. 그 다음에 CSS도 마찬가지로 트리를 생성하고, DOM과 CSSOM을 합쳐서 렌더 트리를 생성합니다. 그 렌더 트리를 가지고 뷰포트에 따라서 레이아웃을 계산하고, 페인팅 작업에 들어갑니다. 마지막으로 페인팅된 요소들을 각각의 레이어로 분리하고, 이 레이어들을 결합해서 최종적으로 컴포지팅, 화면을 구성하게 됩니다.

## 리액트에서 성능 최적화를 위한 방법들을 설명해주세요.

https://www.maeil-mail.kr/question/18

리액트에서 성능 최적화를 하려면 첫 번째, 불필요한 리렌더링을 줄이거나, 두 번째, 코드 로딩 시간을 줄여야 합니다.
첫 번째로 불필요한 리렌더링을 줄이는 방법으로는 메모이제이션이 있습니다. 이미 계산된 결과를 저장해두고 다음에 같은 계산을 반복하는 대신 불러오는 방법인데요. 원래 리액트에서 부모 컴포넌트가 리렌더링될 때 자식도 같이 리렌더링되는데, 부모가 변경되었지만 자식에게 영향이 없는 경우도 있습니다. 자식 컴포넌트를 `React.memo`로 감싸두면 props가 변경되었는지를 확인해서 이 자식에게 오는 props가 변경되지 않았다면 리렌더링하지 않습니다. 하지만 props에 전달되는 값이 함수나 객체일 경우에는, 부모가 리렌더링될 때 새로운 함수나 객체가 생성되어 props가 변경된 것으로 인식되는 한계가 있을 수 있습니다. 그래서 props로 함수가 전달될 때는 useCallback으로 함수를 메모이제이션하고, props가 객체일 때나 아니면 긴 배열의 필터링 결과 같이 비용이 큰 계산을 메모이제이션해야할 때는 useMemo를 사용합니다.
다만 메모이제이션에도 비용이 들고, 리액트도 더 효율적인 리렌더링 방식으로 업데이트되고 있기 때문에 많이 복잡한 계산이 아니면 오히려 성능이 악화될 수도 있어 꼭 필요할 때만 쓰는 게 좋습니다 .
두 번째로 코드 스플리팅을 통해 코드 로딩 시간을 줄일 수 있습니다. 앱이 커서 초기 로딩 속도가 느리거나 페이지별로 필요한 코드가 다를 때, `React.lazy`를 써서 특정 컴포넌트는 필요할 때가 되면 불러오도록 할 수 있습니다.
