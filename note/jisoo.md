1. [리액트에서 성능 최적화를 위한 방법들을 설명해주세요](#리액트에서-성능-최적화를-위한-방법들을-설명해주세요)
2. [그럼 코드 스플리팅은 어떤 경우에 사용해야할까요?](#그럼-코드-스플리팅은-어떤-경우에-사용해야할까요)
3. [React의 Suspense와 Concurrent Mode의 개념을 설명하고, 이를 사용하여 애플리케이션 성능을 최적화할 수 있는 방법을 설명해 주세요](#react의-suspense와-concurrent-mode의-개념을-설명하고-이를-사용하여-애플리케이션-성능을-최적화할-수-있는-방법을-설명해-주세요)
4. [브라우저 렌더링 파이프라인에 대해서 설명해주세요](#브라우저-렌더링-파이프라인에-대해서-설명해주세요)
5. [리플로우와 리페인트 최소화 방법](#리플로우와-리페인트-최소화-방법)
6. [인터넷 창에서 www.google.com을 입력하면 무슨 일이 일어나는지 설명해주세요](#인터넷-창에서-wwwgooglecom을-입력하면-무슨-일이-일어나는지-설명해주세요)
7. [리액트의 render phase와 commit phase에 대해서 설명해주세요](#리액트의-render-phase와-commit-phase에-대해서-설명해주세요)
8. [그럼 render phase와 commit phase는 어떻게 동기화되나요?](#그럼-render-phase와-commit-phase는-어떻게-동기화되나요)
9. [자바스크립트 호이스팅에 대해서 설명해주세요](#자바스크립트-호이스팅에-대해서-설명해주세요)
10. [쿠키, 세션, 웹스토리지의 차이를 설명해보세요](#쿠키,-세션,-웹스토리지의-차이를-설명해보세요)
11. [자바스크립트 함수에 대해서 설명해주세요](#자바스크립트-함수에-대해서-설명해주세요)
12. [CommonJS와 ES Module의 차이점에 대해서 설명해주세요](#CommonJS와-ES-Module의-차이점에-대해서-설명해주세요)
13. [브라우저의 성능 최적화를 할 수 있는 방법에 대해서 설명해주세요](#브라우저의-성능-최적화를-할-수-있는-방법에-대해서-설명해주세요)
14. [디바운스와 쓰로틀에 대해서 설명해주세요](#디바운스와-쓰로틀에-대해서-설명해주세요)
15. [리액트에서 index를 key값으로 사용하면 안되는 이유에 대해서 설명해주세요](#리액트에서-index를-key값으로-사용하면-안되는-이유에-대해서-설명해주세요)
16. [async/await에 대해 설명해보세요](#async/await에-대해-설명해보세요)
17. [useEffect와 useLayoutEffect의 차이점에 대해서 설명해주세요](#useEffect와-useLayoutEffect의-차이점에-대해서-설명해주세요)
18. [웹 접근성의 개념과 개선 방법에 대해 설명해주세요](#웹-접근성의-개념과-개선-방법에-대해-설명해주세요)
19. [SSR(Server Side Rendering)에 대해 설명해주세요](#SSR(Server-Side-Rendering)에-대해-설명해주세요)
20. [CSS Flexbox와 Grid의 차이점에 대해서 설명해주세요](#CSS-Flexbox와-Grid의-차이점에-대해서-설명해주세요)
21. [프론트엔드 E2E 테스트에 대해서 설명해주세요](#프론트엔드-E2E-테스트에-대해서-설명해주세요)
22. [이미지 크기가 클 경우 렌더링 속도가 느려질 텐데, 이를 개선하기 위한 방법들을 설명해주세요](#이미지-크기가-클-경우-렌더링-속도가-느려질-텐데-이를-개선하기-위한-방법들을-설명해주세요)
23. [자바스크립트는 싱글 스레드 언어인데 어떻게 동시에 여러 작업들을 수행하나요?](#자바스크립트는-싱글-스레드-언어인데-어떻게-동시에-여러-작업들을-수행하나요?)
24. [타입스크립트의 타입과 인터페이스의 차이점을 설명해주세요](#타입스크립트의-타입과-인터페이스의-차이점을-설명해주세요)
25. [시맨틱 마크업이란 무엇이며 왜 중요한가요](#시맨틱-마크업이란-무엇이며-왜-중요한가요)
26. [useEffect가 호출되는 시점에 대해 설명해 주세요](#useEffect가-호출되는-시점에-대해-설명해-주세요)
27. [ES6에 대해서 아는 대로 설명해 주세요](#ES6에-대해서-아는-대로-설명해-주세요)
28. [자바스크립트 Promise에 대해서 아는 대로 설명해주세요](#자바스크립트-Promise에-대해서-아는-대로-설명해주세요)
29. [JWT에 대해 설명해주세요](#JWT에-대해-설명해주세요)
30. [웹 보안과 관련된 주요 취약점과 대응 방안에 대해 설명해주세요](#웹-보안과-관련된-주요-취약점과-대응-방안에-대해-설명해주세요)
31. [CORS Cross Origin Resource Sharing에 대해 설명해주세요](#CORS-Cross-Origin-Resource-Sharing에-대해-설명해주세요)
32. [리액트에서 컴포넌트란 무엇인가요?](#리액트에서-컴포넌트란-무엇인가요?)
33. [타입스크립트를 사용하는 이유를 설명해주세요](#타입스크립트를-사용하는-이유를-설명해주세요)
34. [네트워크 요청 최적화 방법에 대해 설명해주세요](#네트워크-요청-최적화-방법에-대해-설명해주세요)
35. [HTTP란 무엇인지 설명해 주세요](#HTTP란-무엇인지-설명해-주세요)
36. [네트워크 통신에서 Body Payload와 Header의 차이는 무엇인가요](#네트워크-통신에서-Body-Payload와-Header의-차이는-무엇인가요)
37. [HTML 데이터 속성data 은 무엇인가요](#HTML-데이터-속성data-은-무엇인가요)
38. [Redux와 Context API의 차이점과 각각의 장단점을 설명해주세요](#Redux와-Context-API의-차이점과-각각의-장단점을-설명해주세요)


---
### 리액트에서 성능 최적화를 위한 방법들을 설명해주세요
리액트 성능 최적화 방법 중 대표적으로 메모이제이션이 있습니다. 리액트 memo는 컴포넌트 props가 변경되지 않았을 때, 리렌더링을 방지하여 성능을 최적화합니다.  
또한 useCallback 과 useMemo를 활용할 수도 있습니다. useCallback은 함수를 메모이제이션하여 불필요한 함수 재생성을 방지합니다. useMemo는 값을 재계산 하는 것을 방지하여 성능을 최적화합니다. 이를 통해 자식 컴포넌트로 전달되는 함수나 값이 변경되지 않으면 리렌더링을 피할 수 있습니다.
마지막으로 코드 스플리팅을 활용해볼 수 있습니다. 코드 스플리팅은 큰 애플리케이션을 여러 개의 작은 청크로 나누어, 필요한 청크만 로드해서 초기 로드 시간을 줄입니다. [리액트는 SPA의 기본 구조로 되어있기 때문에 페이지별로 분리된 코드가 없다면, 모든 코드가 처음 로드될 때 한꺼번에 로드됩니다. 이 경우] React.lazy와 Suspense를 사용하여 동적으로 컴포넌트를 로드하고, 필요한 코드만 로드하여 초기 로드 시간을 개선할 수 있습니다.
### 그럼 코드 스플리팅은 어떤 경우에 사용해야할까요?
첫번째로 초기 로딩시간이 길어지는 경우입니다. 코드 스플리팅을 사용해 초기 로드 시 필요한 코드만 로드하고, 이후 추가적인 기능은 필요할 때 로드하도록 하면 초기 로딩 속도를 개선할 수 있습니다.  
두번째로 라우트별 코드 분할이 필요한 경우입니다. SPA에서는 각 페이지가 별도의 기능과 UI를 가지므로, 라우트별로 필요한 코드만 분리하여 로드할 수 있습니다. 이 방식은 리액트의 React.lasy와 Suspense를 사용해 라우트별 컴포넌트를 동적으로 불러올 때 유용합니다.
### [React의 Suspense와 Concurrent Mode의 개념을 설명하고, 이를 사용하여 애플리케이션 성능을 최적화할 수 있는 방법을 설명해 주세요.]
React의 Suspense는 컴포넌트가 비동기적으로 데이터를 로드하거나 동적으로 로드될 때, 해당 컴포넌트가 준비될 때까지 기다리며 대체 UI를 제공하는 기능입니다. 주로 React.lazy와 함께 사용되어, 동적으로 로드되는 컴포넌트를 보여줄 때까지 로딩 UI를 사용자에게 표시합니다. 이를 통해 비동기 로딩 상태에서 빈 화면을 보여주는 대신, 로딩 UI를 표시해 사용자 경험을 개선할 수 있습니다.
Concurrent Mode는 React의 렌더링 모드로, 여러 작업을 병렬로 처리하여 애플리케이션의 응답성을 향상시키는 기능입니다. 이 모드는 React가 UI 업데이트를 우선순위에 따라 효율적으로 처리할 수 있도록 돕습니다. 예를 들어, useTransition 훅을 사용하면 사용자 입력과 관련된 중요한 작업을 먼저 처리하고, 덜 중요한 작업은 나중에 처리할 수 있게 되어, 사용자 상호작용에 즉각적으로 반응할 수 있습니다.

### 브라우저 렌더링 파이프라인에 대해서 설명해주세요
브라우저가 웹 페이지를 화면에 표시하는 과정을 브라우저 렌더링 파이프라인이라고 합니다. 이 과정은 크게 6가지로 나뉩니다.  
첫번째로 DOM 생성입니다.  
브라우저는 HTML 파일을 파싱하여 DOM 트리를 생성합니다. DOM 트리는 HTML 문서 구조를 계층적으로 표현한 것입니다.  
두번째로 CSSOM 생성입니다.  
브라우저는 CSS파일을 파싱하여 CSSOM 트리를 생성합니다. 이 트리는 스타일 규칙과 HTML 요소를 연결하여 각 요소에 적용될 스타일을 결정합니다.  
세번째로 렌더 트리 생성입니다.  
이제 브라우저는 DOM과 CSSOM을 결합하여 렌더 트리를 생성합니다. 렌더 트리는 화면에 실제로 표시될 요소들로만 구성됩니다.  
네번째로 레이아웃입니다.  
렌더 트리가 생성된 후, 브라우저는 이 트리를 사용해 각 요소의 위치와 크기를 계산하는 레이아웃 과정을 수행합니다.  
화면의 크기가 변경되면 브라우저는 레이아웃을 다시 수행하게 되는데, 이를 리플로우라 합니다. 리플로우는 성능에 영향을 줄 수 있어 최소화하는 것이 중요합니다.  
다섯번째로 페인팅입니다.  
레이아웃이 완료되면, 브라우저는 각 요소를 실제 화면에 그리는 페인팅 작업을 시작합니다. 이 단계에서는 텍스트, 색상, 그림자 같은 모든 시각적 요소가 화면에 그려집니다. 요소의 위치나 크기가 변하지 않는 스타일 속성이 변경될 때 리페인트가 발생합니다. [리페인트는 리플로우보다 비용이 덜 드는 작업이지만, 여전히 성능에 영향을 줄 수 있습니다.]
마지막 단계는 컴포지팅입니다.  
브라우저는 화면에 그려질 요소들을 개별 레이어로 분리하고, 이 레이어들을 결합하여 최종 화면을 구성합니다. [이 과정에서 GPU를 활용하여 각 레이어를 빠르게 합성합니다.]  
### [리플로우와 리페인트 최소화 방법]
리플로우와 리페인트를 유발하지 않는 CSS 속성을 활용하여 애니메이션이나 스타일 변경을 수행하는 것이 좋습니다. 예를 들어, transform이나 opacity를 사용하면 레이아웃이 변경되지 않으므로 리플로우와 리페인트가 발생하지 않고, 컴포지팅 단계에서만 처리됩니다.
반면 width나 margin과 같은 속성은 리플로우를 트리거할 가능성이 높기 때문에 초기 스타일 선언 시에만 설정하는 것이 효율적입니다.  

### 인터넷 창에서 www.google.com를 입력하면 무슨 일이 일어나는지 설명해주세요
먼저 사용자가 주소를 입력하면, 브라우저는 이 도메인 이름을 IP 주소로 변환해야 합니다. 이 과정을 DNS Lookup(조회)라고 합니다. 브라우저는 캐시된 DNS 기록을 먼저 확인하고, 없다면 로컬 DNS 서버에 요청하여 도메인에 해당하는 IP 주소를 얻습니다.
IP 주소가 확인되면, 브라우저는 서버와 TCP 연결을 수립합니다. TCP는 데이터를 신뢰성 있게 전달하기 위한 프로토콜입니다. 이 과정에서 브라우저는 서버와 3-way-handshake를 수행합니다. [즉, 브라우저가 SYN 패킷을 보내고, 서버가 SYN-ACK패킷을 보내며, 다시 브라우저가 ACK 패킷을 보내는 과정입니다.]
TCP 연결이 완료되면, 브라우저는 HTTP또는 HTTPS 요청을 보냅니다. 이 요청은 웹 페이지를 리소스를 요청하는 메세지입니다. HTTPS를 사용할 경우, 이 단계에서 SSL/TLS 핸드셰이크도 수행됩니다.  
서버는 요청을 받고, 해당 리소스를 브라우저에게 응답 보냅니다.  
마지막으로 받은 리소스들을 바탕으로 브라우저 렌더링 파이프라인을 진행합니다. DOM과 CSSOM을 생성하고, 렌더 트리를 구성한 뒤, 레이아웃과 페인트 단계를 통해 웹 페이지가 화면에 표시됩니다.  

### 리액트의 render phase와 commit phase에 대해서 설명해주세요
리액트의 렌더링 과정은 두 가지로 나눌 수 있습니다.

먼저 render phase는 리액트가 변화된 상태나 props에 따라 어떤 UI가 변경되어야 할지를 결정하는 단계입니다. 이 과정에서는 실제로 DOM을 업데이트하지 않고, 변경사항을 가상 DOM에서 계산하여 비교합니다. 이 단계는 순수하게 계산과정이기 때문에 성능에 영향을 주지 않도록 중단되거나 다시 실행될 수 있으며, React 18에서 도입된 Coneurrent Mode를 통해 비동기적으로 처리될 수도 있습니다.

다음으로 commit phase는 실제 변화된 UI를 DOM에 반영하는 단계입니다. 이때 리액트는 가상 DOM에서 계산된 결과를 실제 DOM에 적용하고, 변화된 UI를 브라우저에 렌더링합니다. 이 과정에서 useEffect와 같은 사이드 이펙트가 발생하는 훅들이 실행됩니다.

[정리하자면 render phase는 변화된 UI를 결정하는 과정이고, commit phase는 그 결정된 결과를 실제로 반영하는 단계입니다.]

![image](https://github.com/user-attachments/assets/b873017c-a28a-47e4-a51d-25c314a57f06)


### [그럼 render phase와 commit phase는 어떻게 동기화되나요?]

두가지의 단계로 말씀드릴 수 있습니다. 단계적 진행과 병목 관리입니다. 첫번째로 render phase가 완료되면 리액트는 즉시 commit하지 않고, 다른 높은 우선순위 작업이 있다면 먼저 처리한 후 나중에 commit phase를 실행할 수 있습니다. 이를 통해 React는 동기화가 필요한 작업을 효율적으로 관리합니다.

두번째로 병목 관리입니다. render phase에서 모든 변경 사항이 Fiber Tree에 준비된 상태에서 commit phase로 넘어가므로, render와 commit 단계의 일관성이 유지됩니다. 이렇게 두 단계는 순차적으로 작동하여, UI가 정확하게 동기화되고 불필요한 재렌더링을 방지합니다.


### 자바스크립트 호이스팅에 대해서 설명해주세요

호이스팅은 자바스크립트가 코드를 실행하기 전에 변수와 함수 선언을 코드의 최상단으로 끌어올리는 것처럼 동작하는 특징입니다. 이를 통해 코드 선언 위치와 관계 없이 변수를 사용할 수 있는 것처럼 보일 수 있습니다.  
하지만 호이스팅은 선언의 호이스팅일 뿐, 변수의 값 할당까지 끌어올려지지는 않습니다.  
예를 들어 var로 선언된 변수는 호이스팅 되지만, undefined로 평가됩니다.  
함수의 경우 함수 전체가 호이스팅되기 때문에 호출 이후에 선언해도 문제가 없습니다.  

그러나 ES6에 도입된 let과 const는 호이스팅이 되긴 하지만, 선언 전에 접근하면 ReferenceError가 발생합니다.  
이는 TDZ(Temporal Dead Zone)이라는 개념 때문인데요. TDZ는 변수가 선언되었지만 초기화되기 전가지의 구간을 말합니다. let과 const로 선언된 변수는 TDZ가 존재하며, 이 구간에서는 변수에 접근할 수 없습니다.


### 쿠키, 세션, 웹스토리지의 차이를 설명해보세요

먼저 쿠키는 서버와 클라이언트 데이터 교환에 사용됩니다. 키-값 쌍으로 저장되며 유효기간을 설정할 수 있습니다.  
세션은 서버에 데이터가 저장되며 클라이언트는 세션 ID만 저장합니다. 서버에서 관리되기 때문에 클라이언트에서는 데이터를 조작할 수 없습니다. 세션은 브라우저를 닫으면 만료됩니다.  
웹 스토리지는 브라우저 내부에서 데이터를 저장하며 브라우저를 닫아도 데이터가 삭제되지 않습니다. 쿠키와 동일하게 키-값 쌍으로 저장되며 데이터 교환 시 서버로 전송되지 않습니다.

### 자바스크립트 함수에 대해서 설명해주세요
자바스크립트 함수는 일급 객체로써 다뤄지며 클로저, 고차 함수, 화살표 함수 등의 기능들을 제공합니다.  
일급 객체의 특징은 자바스크립트 함수가 변수에 할당되거나, 다른 함수의 인자로 전달되거나, 함수에서 반환될 수 있다는 점입니다.  
또한 자바스크립트 함수는 함수의 이름이 없는 익명함수로 사용될 수 있으며, 변수에 값처럼 담는 함수 표현식으로도 사용할 수 있습니다.  
함수 선언은 코드가 실행되기 전에 호이스팅되어, 함수선언 이전에 호출할 수 있습니다.  
자바스크립트 함수는 클로저 기능도 제공합니다. 클로저는 함수가 자신이 선언된 환경, 즉 스코프를 기억하고 그 외부 스코프에 접근할 수 있는 기능입니다. 이를 통해 함수는 자신이 선언된 스코프 내의 변수를 참조하고 유지할 수 있습니다.  
마지막으로 고차함수 입니다. 자바스크립트에서는 함수가 일급 객체이기 때문에 다른 함수를 인자로 받거나 반환하는 고차함수를 정의할 수 있습니다.  

### CommonJS와 ES Module의 차이점에 대해서 설명해주세요
**CommonJS**와 **ES Module(ESM)** 은 자바스크립트에서 모듈을 관리하고 불러오는 방식입니다.  
**CommonJS**는 Node.js 환경에서 사용되며, 모듈을 동기적으로 불러옵니다. 주로 서버측에서 많이 사용됩니다.  
**ES Module(ESM)**은 자바스크립트 표준 모듈 시스템으로 ESM은 브라우저와 Node.js 환경에서 모두 사용할 수 있으며, 비동기적으로 로드합니다. 또한 ESM은 정적 분석이 가능해, 트리 쉐이킹과 같은 최적화 작업에도 유리합니다. ESM은 브라우저와 서버 모두에서 사용할 수 있습니다.

### 브라우저의 성능 최적화를 할 수 있는 방법에 대해서 설명해주세요
우선, 코드 스플리팅을 통해 자바스크립트 파일을 필요한 부분만 로드하여 로딩 속도를 개선할 수 있습니다.

또한 레이지 로딩 기법을 사용하여 이미지나 비디오 같은 무거운 리소스를 사용자가 실제로 볼 때만 로드하는 방식을 사용할 수 있습니다. 이렇게 하면 불필요한 리소스 로딩을 줄여 성능을 높일 수 있습니다.

이미지는 파일 크기를 줄이거나 WebP와 같은 가벼운 포맷으로 변환하는 방법이 있습니다.

또한, 캐싱을 활용해 한 번 로딩된 리소스를 다시 다운로드하지 않고 재사용할 수 있어 성능을 향상시킬 수 있습니다.

마지막으로, DOM 크기를 줄이거나 불필요한 CSS 및 자바스크립트 코드를 최소화하는 등의 리소스 최적화 방법을 적용하여 브리우저가 불필요한 렌더링을 하지 않도록 관리하는 것도 성능 개선에 도움이 됩니다.

### 디바운스와 쓰로틀에 대해서 설명해주세요
디바운스와 쓰로틀은 이벤트 핸들러가 너무 자주 실행되지 않도록 조절하는 기법입니다.

먼저 **디바운스**는 이벤트가 연속적으로 발생한 때, 마지막 **이벤트가 발생한 후 일정 시간이 지나야 이벤트 핸들러가 실행**되는 방식 입니다. 이를 통해 불필요하게 많은 이벤트 호출을 방지할 수 있습니다. 예를 들어, 검색창에 사용자가 키를 입력할 때마가 검색 요청을 보내면 부하가 지나치게 커지기 때문에, 사용자 입력을 멈춘 후 일정 시간이 지나면 검색 요청을 보내는 방식으로 적용할 수 있습니다.

**쓰로틀**은 일정 시간 간격 동안 발생한 이벤트 중 첫 번째 또는 마지막 이벤트만 처리하는 방식입니다. 즉, **이벤트가 계속해서 발생하더라도** 설정된 시간 동안은 **한 번만 이벤트 핸들러가 실행**됩니다. 예를 들어, 사용자가 연속 클릭을 한다면 클릭할 때마다 이벤트가 발생하는데, 이를 매번 처리하면 부하가 불필요하게 커지니 쓰로틀을 적용해 일정 간격 내 한 번만 처리하게 할 수 있습니다.

### 디바운스와 쓰로틀 중에서 무한 스크롤 구현 시 어떤 방식을 선택하시겠습니까? 그 이유는 무엇인가요?

무한 스크롤은 쓰로틀을 사용하는 것이 더 적합합니다.  
쓰로틀은 스크롤이 하단에 위치하게 된 순간 즉시 추가 데이터 요청을 수행하므로, 사용자에게 자연스러운 스크롤 경험을 제공할 수 있습니다.  
만약 디바운스를 사용할 경우 스크롤이 멈춘 후에야 데이터를 불러오기 시작하므로 지연이 발생할 수 있습니다.

### 리액트에서 index를 key값으로 사용하면 안되는 이유에 대해서 설명해주세요
리액트에서 index를 key로 사용하는 것을 권장하지 않는 이유는 배열의 요소들이 추가되거나 삭제될 때, 배열의 순서가 바뀌는 문제가 발생할 수 있기 때문입니다.

리액트는 key를 통해 리스트에서 어떤 요소가 변경, 추가, 삭제되었는지 추적합니다. 그러나 index를 key로 사용하면 배열의 순서가 변경될 때 리액트가 요소들을 잘못 인식해 불필요하게 재렌더링 하거나, 요소의 상태를 잘못 처리할 수 있습니다.

이로 인해 성능 문제가 발생하거나, 사용자 입력 상태 같은 요소가 의도치 않게 초기화되는 등 예기치 않은 버그가 생길 수 있습니다.

그래서 배열의 순서나 요소 변경에 영향을 받지 않는 고유한 key로 사용하는 것이 좋습니다.

### key로 사용되는 고유한 값의 생성 방법에는 어떤 것들이 있나요?

주로 데이터의 유일서을 보장하고 변하지 않는 값을 사용하는 것이 중요합니다. 이러한 경우 주로 서버의 데이터베이스에서 제공하는 고유 ID를 사용하는 것이 일반적입니다. 또한 UUID같이 전역적으로 고유한 id 생성이 가능한 라이브러리를 사용해볼 수도 있습니다.

### async/await에 대해 설명해보세요
async/await은자바스크립트에서 비동기 작업을 처리하는 문법입니다.  
`async` 키워드를 함수 앞에 붙이면 해당 함수는 항상 **Promise**를 반환합니다. 함수 내부에서 `await` 키워드를 사용하면, **Promise**가 처리될 때까지 기다린 후 결과 값을 반환할 수 있습니다.  
`async/await`는 기존의 **Promise** 체이닝 방식보다 코드 흐름을 더 직관적이고 간결하게 작성할 수 있게 해줍니다. 이를 통해 비동기 작업을 마치 동기 코드처럼 읽기 쉽게 표현할 수 있습니다.  

### useEffect와 useLayoutEffect의 차이점에 대해서 설명해주세요
useEffect는 렌더링이 완료되는 시점에 비동기적으로 실행됩니다. 즉, 화면이 실제로 사용자에게 그려진 후 useEffect가 실행되는 방식입니다. 그래서 보통 데이터를 가져오는 작업이나 이벤트 리스너 추가 등 렌더링 후에 화면에 직접적인 영향을 주지 않는 작업에 주로 사용됩니다.  
useLayoutEffect는 렌더링 후 DOM이 없데이트되기 직전의 시점에 동기적으로 실행됩니다. 여기서 동기적이라는 것은 화면에 내용이 그려지기 전에 모든 레이아웃 관련 작업이 완료된다는 의미입니다.예를 들어 DOm 의 크기를 측정하거나 위치를 조정해야 할 때 useLayoutEffect를 사용하면 즉각적으로 그 변경사항이 반영되어 화면 깜빡임이나 불필요한 재렌더링을 방지할 수 있습니다.  
단, useLayoutEffect사용 시 성능 면에서 주의할 점이 있습니다. useLayoutEffect는 동기적으로 실행되기 때문에 너무 많은 작업이 실행되면 렌더링이 느려질 수 있습니다. 따라서 보통 useEffect를 기본적으로 사용하고, 화면에 영향을 주는 작업만 useLayoutEffect로 처리하는 것이 좋습니다.  

### 웹 접근성의 개념과 개선 방법에 대해 설명해주세요
웹 접근성은 장애인과 고령자 등 신체적 제약이 있는 사용자를 포함해, 모든 사용자가 웹 페이지를 동등하게 이용할 수 있도록 보장하는 개념입니다.  
웹 접근성 개선에는 다양한 방법이 있습니다. 우선, 단순하고 명확한 HTML 구조와 시맨틱 태그가 필요합니다. 또한 ARIA속성을 활용하여 스크린 리더가 동적 콘텐츠나 복잡한 UI 요소를 올바르게 인식할 수 있게 만들 수 있습니다.  
마지막으로, 키보드로도 페이지를 탐색할 수 있도록 포커스를 명확히 지정하여 키보드 사용자가 필요한 정보에 접근하기 쉽게 해야 합니다.  

### 말씀해주신 방법으로 개선하면 웹 접근성은 완벽해지는 건가요?
웹 접근성을 완벽히 구현하려면 시각 장애뿐만 아니라 청각 장애, 운동 장애, 인지 장애에 대해서도 고려해야 합니다.  
하지만, 모든 장애 유형을 완벽히 대응하는 것은 현실적으로 어렵습니다. 따라서, 단순히 많은 항목을 충족하는 데 매몰되기 보다는, 우리 서비스에서 각 장애 유형 별로 사용자가 어떤 경험을 하고 있는지 파악하는 것이 중요합니다. 예를 들면, 스크린 리더로 탐색해보면 시각 장애 사용자가 어떤 경험을 하고 있는지 파악할 수 있습니다. 이러한 정보를 기반으로 우선순위를 정렬하고, 기업의 상황에 맞게 점진적으로 접근성을 개선해 나가는 것이 지속 가능하고 현실적인 방식일 것입니다.  

### SSR(Server Side Rendering)에 대해 설명해주세요
서버사이드 렌더링 방식은 초기 화면을 클라이언트가 아닌 서버에서 렌더링하여 완성된 HTML을 클라이언트에 내려주는 방식입니다. SSR에서는 서버 단에서 HMTL을 완성해 클라이언트에 전송하고, 클라이언트가 해당 HTML을 파싱만 하여 화면을 그리는 방식입니다.  
반면, 클라이언트사이드 렌더링 방식에서는 브라우저가 서버로부터 비어있는 HTML을 받아온 후, 필요한 자바스크립트 번들을 다운로드하고 실행하여 동적으로 컨텐츠를 채웁니다.  

### SSR의 장점은 무엇인가요?
검색엔진 최적화 측면에서 유리합니다. 화면이 동적으로 그려지는 CSR에 비해 검색 엔진이 크롤링할 때 쉽게 컨텐츠를 인식할 수 있기 때문입니다. 이런 점에서 SSR은 블로그나 커머스 등 SEO가 중요한 웹 애플리케이션에 적합합니다.  
또한, SSR 방식에서는 사용자가 빠른 초기 로딩 속도를 경험할 수 있습니다. CSR과 달리 SSR에서는 번들을 다운로드 받을 필요가 없고, 번들을 실행하여 동적으로 화면을 그려야 할 필요도 없기 때문입니다.  

### SSR의 단점은 없나요?
첫째, 상호작용 초기화가 느립니다. 이는 페이지가 표시되기까지 걸리는 시간(TTV)과 상호작용까지 걸리는 시간(TTI) 사이에 격차가 발생한다는 의미입니다. 그 사이에 사용자가 버튼을 클릭해도 동작하지 않는 등의 답답한 상황을 겪을 수 있습니다.  
둘째, 상대적으로 구현 난이도가 높습니다. 자바스크립트 번들로 대부분의 작업이 수행되는 CSR에 비해 SSR은 과정이 복잡하기 때문입니다.  
마지막으로, 서버 비용이 증가합니다. 정적인 파일을 내려주기만 하면 되는 CSR과 달리, 동적으로 HMTL을 생성하기 위해 서버를 구동해야 하기 때문입니다.  

### CSS Flexbox와 Grid의 차이점에 대해서 설명해주세요
Flexbox는 **1차원 레이아웃이지만, Grid는 2차원 레이아웃**입니다.  
Flexbox는 1차원 레이아웃 속성으로, row 또는 column중 하나를 기준으로 요소를 정렬하고 배치하는 데 최적화되어 있습니다. 주로 행이나 열 중 하나의 방향으로 정렬해야 할 때 유용하며, 복잡한 행과 열을 모두 포함하는 레이아웃에서는 다소 한계가 있습니다.  
Grid는 2차원 레이아웃 속성으로, 행과 열 모두 사용해 요소를 배치할 수 있습니다. 따라서 복잡한 레이아웃을 구성하거나, 웹페이지의 전체적인 구조를 잡는 데 적합합니다.  
또한 사용 목적의 차이가 있습니다.  
Flexbox는 콘텐츠 중심으로, 콘텐츠가 추가되거나 중러들 때 유연하게 대처하기 좋습니다. 예를 들어, 수평 또는 수직 방향으로 콘텐츠를 정렬하고 간격을 조절하는 데 유용하며, 버튼 그룹, 내비게이션 바 등 한 줄의 콘텐츠가 주가 되는 구성에 적합합니다.  
Grid는 레이아웃 중심으로 페이지 구조를 구성하는 데 최적화되어 있습니다. 예를 들어, 카드 레이아웃, 갤러리 형식 등 명확하게 구분된 영역을 기반으로 레아아웃을 구성할 때 효과적입니다.  
마지막으로 기본 동작의 차이가 있습니다.  
Flexbox에서는 주로 요소가 컨테이너의 크기나 위치에 맞춰 자동으로 정렬됩니다.  justify-content와 align-items 속성을 사용해, 주 축 방향으로 요소들을 배치하고 여백을 조절할 수 있습니다.  
Grid는 행과 열을 사전에 정의하고 그 격자(grid cell)에 요소를 배치하는 방식입니다. grid-template-rows, grid-template-columns와 같은 속성으로 행과 열의 크기를 정의하고, 각 요소의 위치를 세밀하게 설정할 수 있습니다.  

### 프론트엔드 E2E 테스트에 대해서 설명해주세요
프론트엔드 E2E테스트는 애플리케이션의 사용자 경험을 처음부터 끝까지 시뮬레이션하여 테스트하는 방식입니다. 단위 테스트나 통합 테스트와 달리, E2E테스트는 사용자 관점에서 전체 애플리케이션이 의도한 대로 작동하는지 검증합니다. 브라우저 환경에서 실제 사용자 동작을 흉내 내어 다양한 시나리오를 테스트하며, 버튼 클릭, 페이지 이동, 데이터 입력 등을 포함합니다. 보통 E2E 테스트는 Cypress, Playwright과 같은 도구를 이용해 작성합니다.  
E2E테스트를 진행하면서 사용자와 동일한 방식으로 애플리케이션을 테스트하므로, 사용자에게 직접적인 영향을 미치는 오류를 조기에 발견할 수 있습니다.  
이는 프로덕트의 안정성을 높이고, 실제 배포 후 발생할 수 있는 리스크를 줄이는 데 도움이 됩니다. 따라서 E2E 테스트는 중요한 사용자 흐름이나 비즈니스 로직이 포함된 페이지에 적용하면 효과적입니다.  

### 유닛 테스트로도 충분히 안정성을 높이고, 리스크를 줄일 수 있지 않나요?
유닛 테스트는 개별적인 코드 조각이 제대로 작동하는지 확인하지만, 전체 시스템의 흐름과 사용자가 실제로 겪는 경험을 확인하지는 않습니다. 예를 들어, 로그인 기능의 유닛 테스트는 올바른 사용자 정보를 입력했을 때 인증이 성공하는지를 확인할 수 있지만, 로그인 이후의 페이지 이동, 세션 유지, 렌더링 등은 확인하지 못합니다.  
반면, E2E 테스트는 애플리케이션을 사용자 관점에서 처음부터 끝까지 검사하여, 모든 시스템이 잘 작동하는지 확인합니다.  
따라서 유닛 테스트와 E2E 테스트를 상호 보완적으로 함께 활용하는 것이 좋습니다. 두 테스트를 함께 활용하면 애플리케이션의 안정성과 신뢰성을 극대화할 수 있습니다.  


### 이미지 크기가 클 경우 렌더링 속도가 느려질 텐데 이를 개선하기 위한 방법들을 설명해주세요
먼저 이미지 포맷 최적화방법이 있습니다. jpeg나 png 대신, 압축 효율이 높은 webP 또는 AVIF와 같은 최신 포맷으로 변환할 수 있습니다. 이 포맷은 이미지 품질을 유지하면서 파일 크기를 크게 줄여줍니다.  
다음 이미지 사이즈 조정입니다. 화면에 노출되는 크기에 비해 이미지가 과도하게 큰 경우 이미지를 작게 리사이징할 수 있습니다. 또한, 다양한 디바이스 해상도에 대응하기 위해 Responsive Images 기술, 즉 `srcset`과 `sizes` 속성을 활용할 수 있습니다. 이 경우, 브라우저가 현재 화면 크기에 최적화된 이미지를 선택하여 로드할 수 있습니다.  
지연 로딩 방법도 있습니다. 사용자가 화면에 스크롤할 때 해당 위치에 도달하는 이미지가 로드되도록 설정하는 방법입니다. 지연 로딩을 통해 초기 로딩 속도를 개선할 수 있습니다. HTML loading=”lazy”속성을 통해 구현할 수 있으며, 불필요한 이미지 로드를 방지할 수 있습니다.  
마지막으로 CDN입니다. CDN을 적용하면 사용자가 지리적으로 가까운 서버에서 이미지를 다운로드하게 되어 로딩 속도를 단축시킬 수 있습니다.  


### WebP나 AVIF는 모든 브라우저에서 지원하지 않는다고 하셨는데, 호환성 문제를 어떻게 해결할 수 있을까요?
호환성 문제에 대비하기 위해 HTML의 `<picture>` 요소를 통해 fallback 이미지를 적용할 수 있습니다. `<picture>` 요소 내부에 WebP나 AVIF와 같은 고효율 포맷을 우선 설정하고, 브라우저가 이를 지원하지 않을 경우 JPEG나 PNG와 같은 기본 포맷을 로드하도록 할 수 있습니다.  
구체적인 예시는 아래와 같습니다.

```html
<picture>
	<source srcset="image.avif" type="image/avif">
	<source srcset="image.webp" type="image/webp">
	<img src="image.jpg" alt="Image description">
</picture>
```

이 코드에서 브라우저는 AVIF를 우선 시도하고, 지원하지 않으면 WebP를, 둘 다 지원하지 않으면 마지막 img 태그의 jpg 이미지를 로드하게 됩니다.  


### 자바스크립트는 싱글 스레드 언어인데 어떻게 동시에 여러 작업들을 수행하나요?
자바스크립트는 싱글 스레드 언어로 한 번에 하나의 작업만을 처리할 수 있는 단일 콜 스택을 가집니다. 하지만 브라우저나 Node.js환경이 제공하는 비동기 처리 메커니즘 덕분에 여러 작업을 동시에 수행할 수 있습니다.  
자바스크립트는 브라우저의 Wep API나 이벤트 루프, 태스크 큐를 이용해 비동기 작업을 동시에 처리합니다.  
비동기 작업이 발생하면, 해당 작업은 브라우저의 Web API에 위임됩니다. 예를 들어, setTimeout이나 fetch와 같은 작업이 수행되면 자바스크립트 엔진은 이 작업들을 Web API에 넘기고 다른 코드실행을 이어갑니다. Web API에서 비동기 작업이 완료되면, 그 작업은 태스크 큐에 들어가 대기합니다.  
이후 **이벤트 루프**가 콜 스택이 비어있는지 확인한 뒤 태스크 큐에서 대기 중인 작업을 콜 스택으로 가져와 실행합니다. 이러한 구조 덕분에 자바스크립트는 싱글 스레드임에도 비동기적으로 작업을 처리하여 다양한 작업을 효율적으로 관리할 수 있습니다. 이 메커니즘 덕분에 UI 인터랙션이 끊기지 않으며, 대기 시간이 필요한 작업도 동시에 실행되는 것과 같이 동작하게 됩니다.  


### 앞서 말씀하신 태스크 큐의 종류에는 어떤 게 있나요?
자바스크립트의 태스크 큐는 크게 **매크로태스크 큐**와 **마이크로태스크 큐**로 나뉩니다. 이들 큐는 비동기 작업의 우선순위를 관리하고, 이벤트 루프가 적절한 시점에 콜백을 실행하기 위해 사용됩니다.  
**매크로태스크 큐**는 일반적인 비동기 작업의 콜백이 저장되는 큐입니다.  
setTimeout, setInterval, I/O작업, 이벤트 핸들러 등은 작업 완료 후 매크로태스크 큐에 콜백을 대기시킵니다. 매크로태스크 큐는 이벤트 루프의 한 번의 반복마다 하나의 태스크만 처리되므로, UI 업데이트나 다른 작업과 균형있게 진행됩니다.  
**마이크로태스크 큐**는 더 높은 우선순위가 필요한 비동기 작업들이 대기하는 큐입니다.  
`Promise.then`, `MutationObserver` 등의 비동기 콜백이 여기에 저장됩니다. 이벤트 루프는 매크로태스크를 실행하기 전에 항상 마이크로태스크 큐를 먼저 확인하고, 모든 마이크로태스크를 처리한 후 매크로태스크로 넘어갑니다. 이 방식으로 마이크로태스크 큐의 작업은 높은 우선순위로 처리됩니다.  

### 타입스크립트의 타입과 인터페이스의 차이점을 설명해주세요
interface는 객체의 형태를 확장하는 데 용이한 반면, type은 튜플, 인터섹션, 유니온 등을 이용하여 더 복잡한 타입 정의 및 조합을 표현하는 데 용이합니다.  
먼저, interface는 선언 병합을 지원해 여러 번 선언할 수 있어, 주로 객체 타입을 확장할 때 유리합니다. 동일한 이름을 가진 interface를 여러 번 선언하면, 이 속성들이 자동으로 합쳐집니다.   
반면, type으로 선언한 경우에는 동일한 이름을 중복 선언하면 에러가 발생합니다. 대신, type은 튜플과 같은 복잡한 타입 표현이 가능하며, 복잡한 타입 조합을 위해 인터섹션(&)과 유니온(|) 연산자를 지원합니다.  

### 시맨틱 마크업이란 무엇이며 왜 중요한가요
시맨틱 마크업은 HTML 요소를 사용하는 방식으로, 단순히 시각적 목적이 아닌 요소의 의미를 잘 나타내도록 작성하는 방식을 말합니다. 예를 들어 `<div>`와 `<span>`같은 비시맨틱 태그가 아닌, `<header>, <footer>, <article>, <section>` 같은 시맨틱 태그를 사용하여 문서 구조와 콘텐츠의 역할을 명확하게 하는 것입니다.  
시맨틱 마크업이 중요한 이유는 크게 두 가지입니다.  
첫째, 접근성을 개선하기 위함입니다. 시맨틱 요소들은 스크린 리더와 같은 접근성 도구에서 콘텐츠의 구조를 더욱 잘 해석할 수 있게 해 주어 시각장애인이나 노인 등 다양한 사용자층이 사이트를 효과적으로 탐색할 수 있게 합니다. 이러한 요소를 올바르게 사용하면, 더 많은 사람들에게 접근 가능한 웹 환경을 제공할 수 있습니다.  
둘째, SEO(검색 엔진 최적화)에 유리합니다. 검색 엔진은 HTML의 시맨틱 구조를 통해 페이지의 구성을 파악합니다. 그렇기에 시맨틱 마크업을 적절히 적용하면, 검색 엔진이 페이지를 올바르게 파악할 수 있고, 그에 따라 검색 결과에서 페이지가 더 잘 노출될 가능성이 높아집니다.  
따라서 시맨틱 마크업은 단순한 코드 작성 컨벤션을 넘어, 웹 접근성과 SEO를 위한 중요한 요소로, 현대 웹 개발에서 필수적인 기술이라고 할 수 있습니다.  

### CSR(Client Side Rendering)에서도 시맨틱 마크업이 SEO에 영향을 미친다고 보시나요? 만약 그렇다면, 왜 그렇다고 생각하시나요?
CSR 환경에서는 시맨틱 마크업이 SEO에 주는 영향이 다소 제한적일 수 있지만, 여전히 중요한 역할을 한다고 생각합니다.  
CSR에서는 대부분의 콘텐츠가 클라이언트 측에서 렌더링되기 때문에, 검색 엔진이 페이지를 크롤링할 때 페이지의 초기 콘텐츠만 인식할 가능성이 큽니다. 그렇더라도 최근 검색 엔진들은 자바스크립트 렌더링을 지원하는 방향으로 진화하고 있으며, 페이지의 시맨틱 구조를 어느 정도 파악할 수 있습니다. 따라서 시맨틱 마크업을 제대로 적용하면 CSR에서도 검색 엔진이 콘텐츠의 중요한 부분을 더 쉽게 인식하게 되어 검색 결과에 긍정적인 영향을 미칠 수 있습니다.  

### useEffect가 호출되는 시점에 대해 설명해 주세요
React useEffect는 컴포넌트의 특정 시점에서 자동으로 호출되는 훅으로, 크게 컴포넌트가 마운트, 업데이트, 언마운트되는 시점에 호출됩니다.  
먼저, 컴포넌트가 마운트될 때, 즉 처음 렌더링되고 나서 호출됩니다. 이때 데이터 초기화나 외부 API 호출, 구독 설정 등의 작업을 실행할 수 있습니다. useEffect는 컴포넌트가 처음 마운트될 때 필요한 초기 작업을 수행할 수 있도록 해줍니다.  
또한, 의존성 배열에 지정된 값이 변경될 때마다 다시 호출됩니다. 두 번째 인자로 주어지는 의존성 배열은 useEffect가 어떤 상태나 props 변화에 반응할지를 결정합니다.  
마지막으로, 컴포넌트가 언마운트될 때 useEffect의 return 값으로 지정된 클린업 함수가 호출됩니다. 이 정리 함수는 이벤트 리스너 제거, 타이머 해제, 구독 취소 등의 작업을 수행하여 컴포넌트가 사라질 때 필요한 정리 작업을 처리할 수 있습니다. 이를 통해 컴포넌트에서 발생한 부수효과를 정리하는 작업을 수행할 수 있습니다.  

### ES6에 대해서 아는 대로 설명해 주세요
**ES6(ECMAScript 2015)는 자바스크립트의 최신 버전**으로, 코드의 가독성과 유지보수성을 높이고, 현대 웹 애플리케이션의 요구를 반영하기 위한 여러 기능들을 제공합니다.  
첫째, **`let`과 `const` 키워드가 추가**됐습니다. `let`은 변수 선언, `const`는 상수 선언에 사용됩니다. `var`와 달리 `let`과 `const`는 블록 스코프를 가지므로 코드의 안정성이 더 높습니다. 또한, 변수 선언 이전에 접근했을 때 `undefined`가 할당되지 않고, `ReferenceError`가 발생한다는 점에서도 차이가 있습니다.  
둘째, **화살표 함수(Arrow Function)가 도입**되었습니다. 기존의 함수 정의 방식보다 간결하고 가독성이 좋습니다. 또한 this의 바인딩을 호출 문맥과 일치시키기 때문에 함수 내부에서의 혼란이 줄었습니다.  
셋째, **클래스 문법이 추가**되었습니다. 이를 통해 객체 지향 프로그래밍의 핵심 개념인 생성자, 상속, 메서드 오버라이딩 등을 자바스크립트에서 활용할 수 있게 되었습니다.  
넷째, **템플릿 리터럴이 추가**되었습니다. 문자열 내에 변수를 손쉽게 삽입할 수 있어, 기존의 문자열 연결 방식보다 가독성과 유연성이 향상되었습니다.  
그 외에도, 구조 분해 할당, Spread Operator와 Rest Parameter, `Promise` 등 중요한 기능들이 ES6를 기점으로 추가되었습니다.

### 자바스크립트 Promise에 대해서 아는 대로 설명해주세요
Promise는 비동기 작업을 관리하고, 해당 작업의 성공 또는 실패 결과를 나중에 사용할 수 있도록 하는 객체입니다. 정리하자면, Promise는 비동기 작업의 완료 여부를 약속해주는 개념이라고 할 수 있습니다.  
자바스크립트는 비동기 처리를 위한 콜백 함수를 많이 사용합니다. 하지만 콜백 함수는 코드가 복잡해짐에 따라 콜백이 중첩되는 “콜백 지옥” 문제를 야기할 수 있습니다. Promise는 이러한 비동기 처리의 가독성을 높이고, 코드 흐름을 명확하게 관리할 수 있도록 도와줍니다.  
Promise는 3가지 상태를 가집니다. 첫번째로 비동기 작업이 아직 완료되지 않은 초기 상태를 나타내는 Pending과 두번째로 비동기 작업이 성공적으로 완료되어 값을 반환하는 상태인 Fulfilled, 그리고 마지막으로 실패 오류를 반환한 상태인 Rejected 입니다.  
이 세 가지 상태 중 하나로 전환되면, 이후에는 다른 상태로 전환되지 않으며, Fulfilled나 Rejected 상태가 되면 결과 값을 통해 해당 작업의 성공 여부를 알 수 있습니다.  
또한 Promise 객체는 비동기 작업을 수행할 함수를 인자로 받아서 실행하며, 이 함수는 resolve와 reject라는 두 가지 콜백을 받습니다.  
resolve는 비동기 작업이 성공했을 때 값을 전달하여 Promise를 fulfilled 상태로 전환하고, reject는 비동기 작업이 실패했을 때 오류를 전달하여 Promise를 rejected 상태로 전환합니다.  
또한 try-catch-finally의 구조로 비동기 작업의 실패와 에러, 또 마지막 부분에 대한 처리를 명시적으로 나타내줄 수 있습니다.  
Promise는 **코드의 가독성을 높이고, 비동기 작업의 흐름을 제어**하는 데에 매우 유용합니다. 특히 여러 개의 Promise를 순차적으로 연결할 수도 있고 Promise.all 이나 allSettled 같은 메서드를 통해 병렬로 비동기 작업을 처리해볼 수도 있습니다.

### 그럼 Promise의 단점은 없나요?
`Promise`는 비동기 작업의 가독성을 높이는데에 도움이 되지만 크게 2가지의 단점이 있습니다.  
첫번째로는 **복잡한 에러 처리**입니다.  
`Promise`는 단일 체인에서는 에러 처리가 간단하지만, 여러 Promise가 중첩되거나 서로 다른 비동기 흐름에서 에러가 발생할 경우 복잡도가 증가할 수 있습니다. 예를 들어, `then` 체인 내의 중간 단계에서 오류가 발생하면 `catch` 블록에서 이를 캐치할 수 있지만, 특정 단계에서만 발생하는 에러를 세밀하게 다루기가 어렵습니다. 따라서 비동기 흐름에서 발생하는 다양한 에러를 모두 처리하려면 코드가 복잡해질 수 있습니다.  
두번째로는 **콜백 지옥을 완전히 해결하지는 못한다**는 점입니다.  
`Promise`는 콜백 지옥 문제를 어느 정도 해결하지만, 비동기 작업이 복잡하게 중첩되면 여전히 콜백과 유사하게 여러 `then` 메서드가 연속해서 사용되며 가독성이 떨어질 수 있습니다. 여러 `Promise`를 순차적으로 실행해야 할 때 `then` 체인을 계속 사용하면 코드의 들여쓰기 구조가 복잡해지고 이해하기 어려워지는 문제점이 있습니다. 이는 async/await을 통해 개선할 수 있습니다.

### JWT에 대해 설명해주세요
JWT는 당사자 간 정보를 JSON 객체로 안전하게 전송하기 위한 독립적인 방법을 정의하는 개방형 표준입니다.  
이 토큰은 디지털 서명이 되어 있어 신뢰할 수 있으며, RSA나 HMAC 알고리즘을 사용하여 서명할 수 있습니다.  
JWT는 Header(토큰 타입과 사용된 알고리즘 정보), Payload(클레임이라 불리는 실제 전달하려는 정보), Signature(토큰의 유효성을 검증하기 위한 서명) 세 부분으로 구성됩니다. 각 부분은 Base64Url로 인코딩되어 점(.)으로 구분됩니다.  
JWT의 장점은 세션 상태를 서버에 저장할 필요가 없어 서버의 확장성이 좋고, 모바일 애플리케이션에서도 쉽게 사용할 수 있다는 것입니다. 하지만 토큰 자체에 정보가 포함되어 있어 크기가 커질 수 있고, 한번 발급된 토큰은 만료되기 전까지 취소가 어렵다는 단점이 있습니다. 또한 토큰이 탈취되면 해당 토큰으로 인증이 가능하기 때문에, 보안에 특별히 신경 써야 하고 중요한 정보는 Payload에 포함시키지 않아야 합니다.  

### 웹 보안과 관련된 주요 취약점과 대응 방안에 대해 설명해주세요
웹 보안에서 가장 흔한 취약점 중 하나는 XSS(Cross-Site Scripting)입니다.  
사용자의 입력값에 포함된 악성 스크립트가 실행되는 것을 방지하기 위해, 모든 사용자 입력은 적절히 이스케이프 처리되어야 합니다.  
React에서는 기본적으로 JSX에서 문자열을 이스케이프 처리하지만, dangerouslySetInnerHTML을 사용할 때는 특별한 주의가 필요합니다. 

CSRF(Cross-Site Request Forgery) 공격을 방지하기 위해서는 토큰 기반의 검증이 필요합니다.  
서버에서 생성한 CSRF 토큰을 클라이언트에서 요청 시 함께 전송하여 검증하는 방식을 사용합니다.  
또한 중요한 API 요청에는 Same-Origin 정책을 적용하고, 필요한 경우에만 CORS를 허용해야 합니다. 
클라이언트 측 저장소(localStorage, sessionStorage)는 XSS 공격에 취약하므로 민감한 정보를 저장하지 않아야 하며, 쿠키를 사용할 때는 HttpOnly, Secure, SameSite 옵션을 적절히 설정해야 합니다. 또한 모든 API 통신은 HTTPS를 통해 이루어져야 하며, 적절한 인증과 권한 검증이 필요합니다.

### CORS Cross Origin Resource Sharing에 대해 설명해주세요
CORS는 다른 출처의 리소스를 공유하는 것을 제어하는 보안 메커니즘입니다. 여기서 '다른 출처'란 프로토콜, 도메인, 포트 중 하나라도 다른 경우를 말하는데요. 예를 들어, 프론트엔드는 localhost:3000에서 실행되고 백엔드 API는 localhost:8080에서 실행될 때, 이 둘은 서로 다른 출처가 됩니다. 이때 브라우저는 보안상의 이유로 이러한 요청을 차단합니다

### CORS가 왜 필요한가요?

CORS는 웹 보안을 위해 필요합니다. 악의적인 사이트가 사용자의 브라우저를 통해 다른 사이트의 리소스에 마음대로 접근하는 것을 방지하기 위해서죠. 이는 사용자 데이터를 보호하고 웹의 안전성을 유지하는 데 중요한 역할을 합니다.

### CORS 관련 이슈는 어떻게 해결하나요?

CORS 이슈를 해결하는 방법은 크게 서버 측과 클라이언트 측 해결방법이 있습니다.

서버 측에서는 Access-Control-Allow-Origin 헤더를 설정하여 특정 출처를 허용할 수 있습니다.
필요한 경우 Access-Control-Allow-Methods, Access-Control-Allow-Headers 등도 설정합니다.
인증이 필요한 요청의 경우 Access-Control-Allow-Credentials도 true로 설정해야 합니다

클라이언트 측에서는 개발 환경에서는 프록시 서버를 설정하여 우회할 수 있습니다.
axios나 fetch 사용 시 credentials 옵션을 적절히 설정합니다.
물론 이러한 설정은 보안을 고려하여 필요한 범위 내에서만 제한적으로 이루어져야 합니다. 무분별한 CORS 허용은 보안 취약점이 될 수 있기 때문입니다.


### 리액트에서 컴포넌트란 무엇인가요?
리액트에서 **컴포넌트는 UI를 구성하는 독립적이고 재사용 가능한 코드 조각**이라고 설명드릴 수 있습니다. 컴포넌트는 특정 기능이나 UI 요소를 캡슐화합니다. 잘 만들어진 컴포넌트는 주로 단일 책임 원칙을 따릅니다.

리액트 내에서 컴포넌트는 크게 **클래스형**과 **함수형**으로 나눌 수 있는데, 최근에는 Hooks의 도입으로 함수형 컴포넌트가 주로 사용되고 있습니다. 함수형 컴포넌트는 더 간결하고 이해하기 쉬운 코드를 작성할 수 있게 해줍니다.

컴포넌트의 주요 장점은 **재사용성**과 **유지보수성**입니다. 예를 들어, 버튼 컴포넌트를 한 번 만들면 여러 페이지에서 다양한 스타일과 기능으로 재사용할 수 있습니다. 또한 컴포넌트는 props를 통해 부모로부터 데이터를 전달받을 수 있어, 동적인 UI를 손쉽게 구현할 수 있습니다.

## **컴포넌트 설계 시 중요하게 고려해야 하는 사항에는 어떤 것들이 있나요?**

React 컴포넌트 설계 시에는 다음과 같은 사항들을 고려해야 합니다.

첫째, **하나의 컴포넌트가 너무 많은 책임을 갖지 않도록 해야 합니다.** 컴포넌트의 역할이 명확하도록 설계해야 합니다. 물론, 이를 고려하지 않아도 정상 작동은 하겠지만, 추후의 유지보수성을 고려해야 하는 상황이라면 하나의 컴포넌트가 너무 많은 책임을 가지지 않도록 하는 것이 중요합니다. 대표적인 예시로, 비즈니스 로직과 UI 로직을 철저히 분리하는 것을 들 수 있습니다.

둘째, **재사용성을 고려**해야 합니다. 만약 특정 컴포넌트가 여러 상황에서 재사용될 가능성이 높다면 유연하게 설계해야 추후 재사용이 용이합니다. props를 통해 필요한 데이터와 동작을 주입받아 다양한 상황에서 쉽게 재사용될 수 있도록 하는 것이 좋습니다.

셋째, **성능 최적화**를 고려해야 합니다. 불필요한 리렌더링을 방지하기 위해 메모이제이션을 적절히 활용하고, 컴포넌트의 크기를 적절히 유지해야 하는 것이 좋습니다.

사실, 이밖에도 고려해야 할 상황이 정말 많으며, 앞서 말씀드린 사항들이 모든 상황에 똑같이 적용되는 것도 아닙니다. 가장 중요한 것은, **각각의 상황에 맞는 컴포넌트를 만드는 것**이라고 생각합니다.


### 타입스크립트를 사용하는 이유를 설명해주세요
타입스크립트를 사용하는 주요 이유로 크게 세 가지를 들 수 있습니다.

첫째, **정적 타이핑을 통해 코드의 안정성을 크게 향상**시킬 수 있습니다. 개발 시 타입 오류를 런타임으로 실행하기 이전에 발견할 수 있어 런타임 에러를 줄이고, 코드의 품질을 개선할 수 있습니다. 이러한 장점은 특히 대규모 프로젝트에서 두드러집니다.

둘째, **개발자의 생산성을 높여줍니다**. IDE의 자동완성 기능과 인텔리센스가 더 많은 정보를 제공할 수 있게 되기 때문에 코드 작성 속도가 빨라지고, 리팩토링이 쉬워집니다. 또한 명시적인 타입 정의가 마치 문서화의 역할을 하여 코드의 가독성과 이해도가 높아집니다.

셋째, **객체지향 프로그래밍의 일부 기능을 자바스크립트에 추가**합니다. 인터페이스, 제네릭, 열거형 등 현대적인 프로그래밍 패러다임을 지원하여 더욱 구조화되고 확장 가능한 코드를 작성할 수 있습니다.

정리하면 타입스크립트는 자바스크립트의 한계를 극복하고, 안정성, 생산성, 기능성 을 향상시키는 데 큰 도움이 됩니다.

### **타입스크립트를 도입하지 않는 것이 더 나은 경우도 있나요?**

타입스크립트를 도입하지 않는 것이 더 적합한 프로젝트는 주로 **개발 속도**와 **간단함**이 중요한 소규모 프로젝트입니다. 예를 들어, **프로토타입 제작**이나 **단순한 랜딩 페이지**처럼 빠른 개발 주기가 요구되고 복잡한 로직이 없는 경우, 타입스크립트를 설정하고 사용하는 것이 오히려 과도한 비용이 될 수 있습니다.

또한, 팀 내에 **타입스크립트에 대한 경험이 부족하거나 러닝 커브를 극복할 시간이 없는 경우**에도 도입을 신중히 고려해야 합니다. 타입스크립트는 초기 설정과 코드 작성이 더 엄격하기 때문에, 팀이 익숙하지 않다면 생산성이 오히려 저하될 수 있습니다.

마지막으로, **기존 자바스크립트 프로젝트가 매우 방대하고, 타입스크립트로 전환하는 데 드는 비용이나 리소스를 감당할 수 없는 경우**에도 도입이 적합하지 않을 수 있습니다. 이런 경우, 점진적 도입 또는 순수 자바스크립트를 유지하면서 코드 리뷰와 테스트 강화로 대안을 마련할 수 있습니다.

### **타입스크립트를 새롭게 도입하는 것을 추진할 때, 팀원들을 어떻게 설득하실 건가요?**

타입스크립트의 장점과 실질적 이점을 명확히 전달하는 것이 중요하다고 생각합니다. 먼저, **타입스크립트가 런타임 에러를 줄이고 코드 안정성을 강화한다**는 점을 강조할 것입니다. 특히, 유지보수 비용이 큰 프로젝트나 복잡한 코드베이스가 있는 상황이라면, 타입 시스템이 협업과 코드 품질을 어떻게 개선할 수 있는지 실제 사례를 통해 차이점을 보여줄 것입니다.

다음으로, **점진적 도입 전략**을 제안할 것 같습니다. 예를 들어, 신규 코드에만 타입스크립트를 부분 도입하거나, 주요 모듈에 한정해 적용하는 방법을 제안해볼 것 같습니다. 또한, 팀이 학습에 부담을 느끼지 않도록 공식 문서, 타입스크립트 핸드북, 그리고 교육 자료를 제공하여 점진적으로 학습할 수 있는 여건이 마련되도록 노력할 것입니다.



### 네트워크 요청 최적화 방법에 대해 설명해주세요
네트워크 요청을 최적화하는 것은 웹 애플리케이션의 성능을 향상시키는 핵심 요소입니다. 

기본적으로 캐싱을 활용해 동일한 데이터에 대한 중복 요청을 방지하고, 브라우저의 캐시 메커니즘을 최대한 활용합니다. 

HTTP 캐시 헤더를 적절히 설정하여 브라우저가 캐시된 리소스를 효율적으로 사용할 수 있게 하며, Service Worker를 통해 오프라인 상태에서도 애플리케이션이 동작할 수 있도록 구현할 수 있습니다.

또한 데이터 전송량을 최소화하기 위해 gzip이나 Brotli 같은 압축 알고리즘을 사용하며, CDN을 활용하여 사용자와 가까운 서버에서 리소스를 제공함으로써 지연 시간을 줄입니다. API 요청의 경우, GraphQL을 사용하여 필요한 데이터만 선택적으로 가져오거나, REST API에서 필요한 필드만 지정하여 요청하는 방식을 사용할 수 있습니다.

### **구체적인 네트워크 요청 최적화 전략들을 설명해주세요.**

구체적인 최적화 전략은 크게 세 가지 영역으로 나눌 수 있습니다.

첫째, 데이터 캐싱 전략입니다. 브라우저의 HTTP 캐시를 활용하여 정적 리소스를 효율적으로 관리하고, 메모리 캐시를 구현하여 자주 사용되는 데이터를 빠르게 접근할 수 있게 합니다. Service Worker를 사용하면 오프라인 상태에서도 애플리케이션이 동작할 수 있으며, localStorage나 sessionStorage를 활용하여 클라이언트 측에서 데이터를 저장하고 관리할 수 있습니다.

둘째, 데이터 전송을 최적화합니다. HTTP/2를 활용하여 여러 요청을 동시에 처리하고, 데이터 압축을 통해 전송량을 줄입니다. CDN을 사용하여 사용자와 가까운 위치에서 리소스를 제공하며, 이미지 최적화를 통해 불필요한 데이터 전송을 방지합니다. 특히 이미지의 경우 WebP 형식을 사용하거나 적절한 크기로 리사이징하여 제공합니다.

셋째, 요청 제어 기법을 구현합니다. 사용자 입력에 따른 연속적인 API 요청을 제어하기 위해 디바운싱이나 쓰로틀링을 적용합니다. 필요한 경우 요청의 우선순위를 조정하여 중요한 데이터를 먼저 로드합니다.

이러한 전략들은 상황과 요구사항에 따라 적절히 조합하여 사용해야 하며, 구현 시에는 데이터의 일관성, 에러 처리, 그리고 실제 성능 향상을 측정하고 모니터링하는 것이 중요합니다.


### HTTP란 무엇인지 설명해 주세요
**HTTP(Hypertext Transfer Protocol) 는 웹 상에서 클라이언트와 서버 간 데이터를 주고받는 데 사용되는 통신 규약**입니다. 클라이언트가 서버에 요청을 보내고, 서버가 이에 대한 응답을 반환하는 방식으로 동작합니다. HTTP는 **비연결성(stateless)** 을 특징으로 하여 한 번의 요청-응답이 끝나면 연결이 종료됩니다. 또한, 통신이 안전하게 연결될 수 있도록 TCP 연결을 사용합니다.

HTTP는 HTML, JSON 등 **다양한 데이터 포맷**을 전달할 수 있습니다. 요청과 응답에는 **URL 경로, 각종 메서드, 상태 코드와 헤더** 등 정해진 몇 가지 정보를 포함합니다.

HTTP의 보안을 강화한 버전인 **HTTPS(Hypertext Transfer Protocol Secure)** 는 HTTP에 TLS/SSL 프로토콜에 따라 데이터를 암호화하여 전송합니다. 이를 통해 보안 상 중요한 정보들을 안전하게 보호하여 통신을 주고 받습니다.

## **HTTP와 함께 자주 언급되는 RESTFul API은 무엇인가요?**

**RESTful API는 REST(Representational State Transfer) 스타일을 준수하여 설계된 API**를 의미합니다. 여기서 **REST는 웹의 리소스를 클라이언트와 서버가 일관된 방식으로 처리할 수 있도록 하는 설계 원칙**입니다.

기본적으로 REST에서는 리소스를 고유한 URI로 표현하고, HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용해 행위를 표현합니다. 예를 들어, /users URI에 GET 요청을 보내면 사용자 목록을 가져오는 API로 동작할 수 있습니다.

다음은 REST의 핵심 규칙들입니다.

1. **클라이언트-서버 분리**: 클라이언트와 서버 간 역할을 명확히 분리합니다.
2. **무상태성(Stateless)**: 서버는 클라이언트의 상태를 저장하지 않으며, 각 요청은 독립적으로 처리합니다.
3. **일관된 인터페이스(Uniform Interface)**: 고유한 URI로 리소스를 식별하고 일관된 인터페이스를 통해 클라이언트와 서버가 간단하고 예측 가능하게 통신할 수 있게 합니다.
4. **캐시 가능성**: 가능하다면, 서버의 응답 시간을 개선하기 위해 리소스 캐싱을 지원합니다.


### 네트워크 통신에서 Body Payload와 Header의 차이는 무엇인가요
Body와 Header의 가장 큰 차이는 **정보(데이터)의 역할**입니다.
**Header**는 **데이터의 메타 정보**를 담습니다. 즉, 데이터 자체가 아니라 데이터에 대한 컨텍스트 정보를 포함합니다. 이로써 **수신자가 데이터를 어떻게 처리해야 할지 지침을 제공**하는 역할을 합니다. 예를 들어, HTTP 요청이나 응답에서 Header에는 Content-Type, Authorization, Cache-Control과 같은 정보가 포함됩니다. 이는 정보의 유형, 인증 정보, 캐시 설정 등 컨텍스트 정보를 전달합니다.

반면 **Body는 전송하려는 실제 데이터**를 의미합니다. HTTP 요청에서 서버로 전달하는 JSON 데이터나 폼 데이터가 이에 해당됩니다. 일반적으로 헤더에 비해 복잡하고 용량이 큰 데이터를 포함합니다.

즉, Header는 네트워크 통신에서 안내 역할을, Body는 본질적인 데이터를 전달하는 역할을 맡고 있습니다. 이 둘의 조화가 효율적인 통신을 가능하게 합니다.

### **Header 크기에 제한이 있나요?**

HTTP 표준을 정의하는 문서인 HTTP RFC에 따르면, Header의 명시적인 크기 제한은 정해져 있지 않습니다. 다만, Apache, Nginx와 같은 웹서버 단에서 Header의 크기를 제한하고 있는 경우가 많습니다. 일반적으로, 8KB-16KB로 설정되어 있습니다. 이러한 제한값을 초과할 경우, 일반적으로 응답코드 413(Content Too Large)를 응답합니다.


### HTML 데이터 속성data 은 무엇인가요
**데이터 속성은 사용자 정의 데이터를 HTML 요소에 저장하기 위해 사용되는 속성**입니다. 선언 방법은 `data-`로 시작하는 속성을 HTML 태그에 추가하면 됩니다. 예를 들어, `<div data-user-id="12345" data-role="admin"></div>`와 같이 사용할 수 있습니다. 여기서 `data-user-id`와 `data-role`이 데이터 속성에 해당합니다.

데이터 속성은 자바스크립트를 통해 읽을 수 있습니다. 구체적으로는, 자바스크립트에서 dataset 객체를 사용하여 요소의 데이터 속성에 접근할 수 있습니다. 예를 들어, 위의 요소에서 `해당요소.dataset.userId`를 호출하면 "12345"라는 값이 반환됩니다.

또한, CSS에서도 `attr()` 함수나 속성 선택자를 통해 접근할 수 있습니다.

```css
/* attr() 함수를 사용하여 접근 */
article::before {
  content: attr(data-parent);
}

/* 속성 선택자를 사용하여 접근 */
article[data-columns="3"] {
  width: 400px;
}
```

## **데이터 속성은 언제 활용하나요?**

**DOM 요소에 특정 데이터를 바인딩하고, 자바스크립트 로직에서 해당 데이터를 활용하기 위해 사용**됩니다. 예를 들어, 버튼 클릭 이벤트에서 특정 데이터를 전달하거나, 데이터를 기반으로 UI를 동적으로 변경해야 할 때 유용합니다. 이렇게 하면 HTML과 자바스크립트 간 데이터 상호작용을 간단하게 구현할 수 있습니다.


### Redux와 Context API의 차이점과 각각의 장단점을 설명해주세요
Redux와 Context API의 가장 큰 차이점은 **목적과 사용 방식**에 있습니다.

Context API는 React에 내장 된 기능으로, 주로 컴포넌트 트리 안에서 데이터를 공유하기 위한 목적으로 설계되었습니다. 특히 props drilling 문제를 해결하기 위한 간단한 솔루션을 제공하는 것이 주 목적입니다.

Provider로 감싼 하위 컴포넌트들은 Consumer를 통해 해당 데이터에 직접 접근할 수 있으며, 별도의 상태 관리 패턴이나 규칙을 따르지 않아도 됩니다.

반면 Redux는 전체 애플리케이션의 상태를 관리하기 위한 독립적인 상태 관리 라이브러리입니다. Redux는 단방향 데이터 흐름과 불변성을 강조하며, 액션(Action)을 디스패치하고 리듀서(Reducer)를 통해 상태를 변경하는 엄격한 패턴을 따릅니다. 모든 상태 변화는 예측 가능하고 추적 가능해야 한다는 철학을 가지고 있으며, 이를 위해 미들웨어와 같은 추가적인 기능들을 제공합니다.

Context API는 간단한 상태 공유에는 적합하지만, 복잡한 상태 로직이나 빈번한 업데이트가 필요한 경우에는 성능 이슈가 발생할 수 있습니다. 또한 상태 변화를 추적하거나 디버깅하기 위한 도구가 기본적으로 제공되지 않습니다. 반면 Redux는 강력한 개발자 도구와 미들웨어 시스템을 통해 복잡한 상태 관리와 디버깅을 용이하게 만들어주지만, 이를 위해 더 많은 보일러플레이트 코드와 학습이 필요합니다.

결과적으로 Context API는 간단한 전역 상태 관리나 정적인 데이터 공유에 적합하고, Redux는 복잡한 상태 로직과 빈번한 업데이트가 필요한 대규모 애플리케이션에 더 적합합니다. 실제 프로젝트에서는 애플리케이션의 규모와 요구사항에 따라 둘 중 하나를 선택하거나, 때로는 둘을 함께 사용하여 각각의 장점을 활용하는 방식을 택할 수 있습니다.

















